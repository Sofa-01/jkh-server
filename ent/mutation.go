// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"jkh/ent/building"
	"jkh/ent/checklist"
	"jkh/ent/checklistelement"
	"jkh/ent/district"
	"jkh/ent/elementcatalog"
	"jkh/ent/inspectionact"
	"jkh/ent/inspectionresult"
	"jkh/ent/inspectorunit"
	"jkh/ent/jkhunit"
	"jkh/ent/predicate"
	"jkh/ent/role"
	"jkh/ent/task"
	"jkh/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBuilding         = "Building"
	TypeChecklist        = "Checklist"
	TypeChecklistElement = "ChecklistElement"
	TypeDistrict         = "District"
	TypeElementCatalog   = "ElementCatalog"
	TypeInspectionAct    = "InspectionAct"
	TypeInspectionResult = "InspectionResult"
	TypeInspectorUnit    = "InspectorUnit"
	TypeJkhUnit          = "JkhUnit"
	TypeRole             = "Role"
	TypeTask             = "Task"
	TypeUser             = "User"
)

// BuildingMutation represents an operation that mutates the Building nodes in the graph.
type BuildingMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	address              *string
	construction_year    *int
	addconstruction_year *int
	description          *string
	photo                *string
	clearedFields        map[string]struct{}
	jkh_unit             *int
	clearedjkh_unit      bool
	district             *int
	cleareddistrict      bool
	inspector            *int
	clearedinspector     bool
	tasks                map[int]struct{}
	removedtasks         map[int]struct{}
	clearedtasks         bool
	done                 bool
	oldValue             func(context.Context) (*Building, error)
	predicates           []predicate.Building
}

var _ ent.Mutation = (*BuildingMutation)(nil)

// buildingOption allows management of the mutation configuration using functional options.
type buildingOption func(*BuildingMutation)

// newBuildingMutation creates new mutation for the Building entity.
func newBuildingMutation(c config, op Op, opts ...buildingOption) *BuildingMutation {
	m := &BuildingMutation{
		config:        c,
		op:            op,
		typ:           TypeBuilding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBuildingID sets the ID field of the mutation.
func withBuildingID(id int) buildingOption {
	return func(m *BuildingMutation) {
		var (
			err   error
			once  sync.Once
			value *Building
		)
		m.oldValue = func(ctx context.Context) (*Building, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Building.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBuilding sets the old Building of the mutation.
func withBuilding(node *Building) buildingOption {
	return func(m *BuildingMutation) {
		m.oldValue = func(context.Context) (*Building, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BuildingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BuildingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BuildingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BuildingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Building.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDistrictID sets the "district_id" field.
func (m *BuildingMutation) SetDistrictID(i int) {
	m.district = &i
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *BuildingMutation) DistrictID() (r int, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldDistrictID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *BuildingMutation) ResetDistrictID() {
	m.district = nil
}

// SetJkhUnitID sets the "jkh_unit_id" field.
func (m *BuildingMutation) SetJkhUnitID(i int) {
	m.jkh_unit = &i
}

// JkhUnitID returns the value of the "jkh_unit_id" field in the mutation.
func (m *BuildingMutation) JkhUnitID() (r int, exists bool) {
	v := m.jkh_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldJkhUnitID returns the old "jkh_unit_id" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldJkhUnitID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJkhUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJkhUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJkhUnitID: %w", err)
	}
	return oldValue.JkhUnitID, nil
}

// ResetJkhUnitID resets all changes to the "jkh_unit_id" field.
func (m *BuildingMutation) ResetJkhUnitID() {
	m.jkh_unit = nil
}

// SetInspectorID sets the "inspector_id" field.
func (m *BuildingMutation) SetInspectorID(i int) {
	m.inspector = &i
}

// InspectorID returns the value of the "inspector_id" field in the mutation.
func (m *BuildingMutation) InspectorID() (r int, exists bool) {
	v := m.inspector
	if v == nil {
		return
	}
	return *v, true
}

// OldInspectorID returns the old "inspector_id" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldInspectorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInspectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInspectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInspectorID: %w", err)
	}
	return oldValue.InspectorID, nil
}

// ClearInspectorID clears the value of the "inspector_id" field.
func (m *BuildingMutation) ClearInspectorID() {
	m.inspector = nil
	m.clearedFields[building.FieldInspectorID] = struct{}{}
}

// InspectorIDCleared returns if the "inspector_id" field was cleared in this mutation.
func (m *BuildingMutation) InspectorIDCleared() bool {
	_, ok := m.clearedFields[building.FieldInspectorID]
	return ok
}

// ResetInspectorID resets all changes to the "inspector_id" field.
func (m *BuildingMutation) ResetInspectorID() {
	m.inspector = nil
	delete(m.clearedFields, building.FieldInspectorID)
}

// SetAddress sets the "address" field.
func (m *BuildingMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *BuildingMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *BuildingMutation) ResetAddress() {
	m.address = nil
}

// SetConstructionYear sets the "construction_year" field.
func (m *BuildingMutation) SetConstructionYear(i int) {
	m.construction_year = &i
	m.addconstruction_year = nil
}

// ConstructionYear returns the value of the "construction_year" field in the mutation.
func (m *BuildingMutation) ConstructionYear() (r int, exists bool) {
	v := m.construction_year
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionYear returns the old "construction_year" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldConstructionYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstructionYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstructionYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionYear: %w", err)
	}
	return oldValue.ConstructionYear, nil
}

// AddConstructionYear adds i to the "construction_year" field.
func (m *BuildingMutation) AddConstructionYear(i int) {
	if m.addconstruction_year != nil {
		*m.addconstruction_year += i
	} else {
		m.addconstruction_year = &i
	}
}

// AddedConstructionYear returns the value that was added to the "construction_year" field in this mutation.
func (m *BuildingMutation) AddedConstructionYear() (r int, exists bool) {
	v := m.addconstruction_year
	if v == nil {
		return
	}
	return *v, true
}

// ClearConstructionYear clears the value of the "construction_year" field.
func (m *BuildingMutation) ClearConstructionYear() {
	m.construction_year = nil
	m.addconstruction_year = nil
	m.clearedFields[building.FieldConstructionYear] = struct{}{}
}

// ConstructionYearCleared returns if the "construction_year" field was cleared in this mutation.
func (m *BuildingMutation) ConstructionYearCleared() bool {
	_, ok := m.clearedFields[building.FieldConstructionYear]
	return ok
}

// ResetConstructionYear resets all changes to the "construction_year" field.
func (m *BuildingMutation) ResetConstructionYear() {
	m.construction_year = nil
	m.addconstruction_year = nil
	delete(m.clearedFields, building.FieldConstructionYear)
}

// SetDescription sets the "description" field.
func (m *BuildingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BuildingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BuildingMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[building.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BuildingMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[building.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BuildingMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, building.FieldDescription)
}

// SetPhoto sets the "photo" field.
func (m *BuildingMutation) SetPhoto(s string) {
	m.photo = &s
}

// Photo returns the value of the "photo" field in the mutation.
func (m *BuildingMutation) Photo() (r string, exists bool) {
	v := m.photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "photo" field's value of the Building entity.
// If the Building object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BuildingMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ClearPhoto clears the value of the "photo" field.
func (m *BuildingMutation) ClearPhoto() {
	m.photo = nil
	m.clearedFields[building.FieldPhoto] = struct{}{}
}

// PhotoCleared returns if the "photo" field was cleared in this mutation.
func (m *BuildingMutation) PhotoCleared() bool {
	_, ok := m.clearedFields[building.FieldPhoto]
	return ok
}

// ResetPhoto resets all changes to the "photo" field.
func (m *BuildingMutation) ResetPhoto() {
	m.photo = nil
	delete(m.clearedFields, building.FieldPhoto)
}

// ClearJkhUnit clears the "jkh_unit" edge to the JkhUnit entity.
func (m *BuildingMutation) ClearJkhUnit() {
	m.clearedjkh_unit = true
	m.clearedFields[building.FieldJkhUnitID] = struct{}{}
}

// JkhUnitCleared reports if the "jkh_unit" edge to the JkhUnit entity was cleared.
func (m *BuildingMutation) JkhUnitCleared() bool {
	return m.clearedjkh_unit
}

// JkhUnitIDs returns the "jkh_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JkhUnitID instead. It exists only for internal usage by the builders.
func (m *BuildingMutation) JkhUnitIDs() (ids []int) {
	if id := m.jkh_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJkhUnit resets all changes to the "jkh_unit" edge.
func (m *BuildingMutation) ResetJkhUnit() {
	m.jkh_unit = nil
	m.clearedjkh_unit = false
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *BuildingMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[building.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *BuildingMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *BuildingMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *BuildingMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// ClearInspector clears the "inspector" edge to the User entity.
func (m *BuildingMutation) ClearInspector() {
	m.clearedinspector = true
	m.clearedFields[building.FieldInspectorID] = struct{}{}
}

// InspectorCleared reports if the "inspector" edge to the User entity was cleared.
func (m *BuildingMutation) InspectorCleared() bool {
	return m.InspectorIDCleared() || m.clearedinspector
}

// InspectorIDs returns the "inspector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InspectorID instead. It exists only for internal usage by the builders.
func (m *BuildingMutation) InspectorIDs() (ids []int) {
	if id := m.inspector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInspector resets all changes to the "inspector" edge.
func (m *BuildingMutation) ResetInspector() {
	m.inspector = nil
	m.clearedinspector = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *BuildingMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *BuildingMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *BuildingMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *BuildingMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *BuildingMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *BuildingMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *BuildingMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the BuildingMutation builder.
func (m *BuildingMutation) Where(ps ...predicate.Building) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BuildingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BuildingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Building, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BuildingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BuildingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Building).
func (m *BuildingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BuildingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.district != nil {
		fields = append(fields, building.FieldDistrictID)
	}
	if m.jkh_unit != nil {
		fields = append(fields, building.FieldJkhUnitID)
	}
	if m.inspector != nil {
		fields = append(fields, building.FieldInspectorID)
	}
	if m.address != nil {
		fields = append(fields, building.FieldAddress)
	}
	if m.construction_year != nil {
		fields = append(fields, building.FieldConstructionYear)
	}
	if m.description != nil {
		fields = append(fields, building.FieldDescription)
	}
	if m.photo != nil {
		fields = append(fields, building.FieldPhoto)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BuildingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case building.FieldDistrictID:
		return m.DistrictID()
	case building.FieldJkhUnitID:
		return m.JkhUnitID()
	case building.FieldInspectorID:
		return m.InspectorID()
	case building.FieldAddress:
		return m.Address()
	case building.FieldConstructionYear:
		return m.ConstructionYear()
	case building.FieldDescription:
		return m.Description()
	case building.FieldPhoto:
		return m.Photo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BuildingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case building.FieldDistrictID:
		return m.OldDistrictID(ctx)
	case building.FieldJkhUnitID:
		return m.OldJkhUnitID(ctx)
	case building.FieldInspectorID:
		return m.OldInspectorID(ctx)
	case building.FieldAddress:
		return m.OldAddress(ctx)
	case building.FieldConstructionYear:
		return m.OldConstructionYear(ctx)
	case building.FieldDescription:
		return m.OldDescription(ctx)
	case building.FieldPhoto:
		return m.OldPhoto(ctx)
	}
	return nil, fmt.Errorf("unknown Building field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case building.FieldDistrictID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	case building.FieldJkhUnitID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJkhUnitID(v)
		return nil
	case building.FieldInspectorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInspectorID(v)
		return nil
	case building.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case building.FieldConstructionYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionYear(v)
		return nil
	case building.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case building.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BuildingMutation) AddedFields() []string {
	var fields []string
	if m.addconstruction_year != nil {
		fields = append(fields, building.FieldConstructionYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BuildingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case building.FieldConstructionYear:
		return m.AddedConstructionYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BuildingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case building.FieldConstructionYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConstructionYear(v)
		return nil
	}
	return fmt.Errorf("unknown Building numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BuildingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(building.FieldInspectorID) {
		fields = append(fields, building.FieldInspectorID)
	}
	if m.FieldCleared(building.FieldConstructionYear) {
		fields = append(fields, building.FieldConstructionYear)
	}
	if m.FieldCleared(building.FieldDescription) {
		fields = append(fields, building.FieldDescription)
	}
	if m.FieldCleared(building.FieldPhoto) {
		fields = append(fields, building.FieldPhoto)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BuildingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BuildingMutation) ClearField(name string) error {
	switch name {
	case building.FieldInspectorID:
		m.ClearInspectorID()
		return nil
	case building.FieldConstructionYear:
		m.ClearConstructionYear()
		return nil
	case building.FieldDescription:
		m.ClearDescription()
		return nil
	case building.FieldPhoto:
		m.ClearPhoto()
		return nil
	}
	return fmt.Errorf("unknown Building nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BuildingMutation) ResetField(name string) error {
	switch name {
	case building.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	case building.FieldJkhUnitID:
		m.ResetJkhUnitID()
		return nil
	case building.FieldInspectorID:
		m.ResetInspectorID()
		return nil
	case building.FieldAddress:
		m.ResetAddress()
		return nil
	case building.FieldConstructionYear:
		m.ResetConstructionYear()
		return nil
	case building.FieldDescription:
		m.ResetDescription()
		return nil
	case building.FieldPhoto:
		m.ResetPhoto()
		return nil
	}
	return fmt.Errorf("unknown Building field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BuildingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.jkh_unit != nil {
		edges = append(edges, building.EdgeJkhUnit)
	}
	if m.district != nil {
		edges = append(edges, building.EdgeDistrict)
	}
	if m.inspector != nil {
		edges = append(edges, building.EdgeInspector)
	}
	if m.tasks != nil {
		edges = append(edges, building.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BuildingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeJkhUnit:
		if id := m.jkh_unit; id != nil {
			return []ent.Value{*id}
		}
	case building.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case building.EdgeInspector:
		if id := m.inspector; id != nil {
			return []ent.Value{*id}
		}
	case building.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BuildingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtasks != nil {
		edges = append(edges, building.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BuildingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case building.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BuildingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedjkh_unit {
		edges = append(edges, building.EdgeJkhUnit)
	}
	if m.cleareddistrict {
		edges = append(edges, building.EdgeDistrict)
	}
	if m.clearedinspector {
		edges = append(edges, building.EdgeInspector)
	}
	if m.clearedtasks {
		edges = append(edges, building.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BuildingMutation) EdgeCleared(name string) bool {
	switch name {
	case building.EdgeJkhUnit:
		return m.clearedjkh_unit
	case building.EdgeDistrict:
		return m.cleareddistrict
	case building.EdgeInspector:
		return m.clearedinspector
	case building.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BuildingMutation) ClearEdge(name string) error {
	switch name {
	case building.EdgeJkhUnit:
		m.ClearJkhUnit()
		return nil
	case building.EdgeDistrict:
		m.ClearDistrict()
		return nil
	case building.EdgeInspector:
		m.ClearInspector()
		return nil
	}
	return fmt.Errorf("unknown Building unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BuildingMutation) ResetEdge(name string) error {
	switch name {
	case building.EdgeJkhUnit:
		m.ResetJkhUnit()
		return nil
	case building.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case building.EdgeInspector:
		m.ResetInspector()
		return nil
	case building.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Building edge %s", name)
}

// ChecklistMutation represents an operation that mutates the Checklist nodes in the graph.
type ChecklistMutation struct {
	config
	op              Op
	typ             string
	id              *int
	title           *string
	inspection_type *checklist.InspectionType
	description     *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	elements        map[int]struct{}
	removedelements map[int]struct{}
	clearedelements bool
	tasks           map[int]struct{}
	removedtasks    map[int]struct{}
	clearedtasks    bool
	done            bool
	oldValue        func(context.Context) (*Checklist, error)
	predicates      []predicate.Checklist
}

var _ ent.Mutation = (*ChecklistMutation)(nil)

// checklistOption allows management of the mutation configuration using functional options.
type checklistOption func(*ChecklistMutation)

// newChecklistMutation creates new mutation for the Checklist entity.
func newChecklistMutation(c config, op Op, opts ...checklistOption) *ChecklistMutation {
	m := &ChecklistMutation{
		config:        c,
		op:            op,
		typ:           TypeChecklist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChecklistID sets the ID field of the mutation.
func withChecklistID(id int) checklistOption {
	return func(m *ChecklistMutation) {
		var (
			err   error
			once  sync.Once
			value *Checklist
		)
		m.oldValue = func(ctx context.Context) (*Checklist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Checklist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChecklist sets the old Checklist of the mutation.
func withChecklist(node *Checklist) checklistOption {
	return func(m *ChecklistMutation) {
		m.oldValue = func(context.Context) (*Checklist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChecklistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChecklistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChecklistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChecklistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Checklist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ChecklistMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ChecklistMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Checklist entity.
// If the Checklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChecklistMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ChecklistMutation) ResetTitle() {
	m.title = nil
}

// SetInspectionType sets the "inspection_type" field.
func (m *ChecklistMutation) SetInspectionType(ct checklist.InspectionType) {
	m.inspection_type = &ct
}

// InspectionType returns the value of the "inspection_type" field in the mutation.
func (m *ChecklistMutation) InspectionType() (r checklist.InspectionType, exists bool) {
	v := m.inspection_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInspectionType returns the old "inspection_type" field's value of the Checklist entity.
// If the Checklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChecklistMutation) OldInspectionType(ctx context.Context) (v checklist.InspectionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInspectionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInspectionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInspectionType: %w", err)
	}
	return oldValue.InspectionType, nil
}

// ResetInspectionType resets all changes to the "inspection_type" field.
func (m *ChecklistMutation) ResetInspectionType() {
	m.inspection_type = nil
}

// SetDescription sets the "description" field.
func (m *ChecklistMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChecklistMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Checklist entity.
// If the Checklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChecklistMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChecklistMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[checklist.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChecklistMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[checklist.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChecklistMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, checklist.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *ChecklistMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChecklistMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Checklist entity.
// If the Checklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChecklistMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChecklistMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddElementIDs adds the "elements" edge to the ChecklistElement entity by ids.
func (m *ChecklistMutation) AddElementIDs(ids ...int) {
	if m.elements == nil {
		m.elements = make(map[int]struct{})
	}
	for i := range ids {
		m.elements[ids[i]] = struct{}{}
	}
}

// ClearElements clears the "elements" edge to the ChecklistElement entity.
func (m *ChecklistMutation) ClearElements() {
	m.clearedelements = true
}

// ElementsCleared reports if the "elements" edge to the ChecklistElement entity was cleared.
func (m *ChecklistMutation) ElementsCleared() bool {
	return m.clearedelements
}

// RemoveElementIDs removes the "elements" edge to the ChecklistElement entity by IDs.
func (m *ChecklistMutation) RemoveElementIDs(ids ...int) {
	if m.removedelements == nil {
		m.removedelements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.elements, ids[i])
		m.removedelements[ids[i]] = struct{}{}
	}
}

// RemovedElements returns the removed IDs of the "elements" edge to the ChecklistElement entity.
func (m *ChecklistMutation) RemovedElementsIDs() (ids []int) {
	for id := range m.removedelements {
		ids = append(ids, id)
	}
	return
}

// ElementsIDs returns the "elements" edge IDs in the mutation.
func (m *ChecklistMutation) ElementsIDs() (ids []int) {
	for id := range m.elements {
		ids = append(ids, id)
	}
	return
}

// ResetElements resets all changes to the "elements" edge.
func (m *ChecklistMutation) ResetElements() {
	m.elements = nil
	m.clearedelements = false
	m.removedelements = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ChecklistMutation) AddTaskIDs(ids ...int) {
	if m.tasks == nil {
		m.tasks = make(map[int]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ChecklistMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ChecklistMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ChecklistMutation) RemoveTaskIDs(ids ...int) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ChecklistMutation) RemovedTasksIDs() (ids []int) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ChecklistMutation) TasksIDs() (ids []int) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ChecklistMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the ChecklistMutation builder.
func (m *ChecklistMutation) Where(ps ...predicate.Checklist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChecklistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChecklistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Checklist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChecklistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChecklistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Checklist).
func (m *ChecklistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChecklistMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.title != nil {
		fields = append(fields, checklist.FieldTitle)
	}
	if m.inspection_type != nil {
		fields = append(fields, checklist.FieldInspectionType)
	}
	if m.description != nil {
		fields = append(fields, checklist.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, checklist.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChecklistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checklist.FieldTitle:
		return m.Title()
	case checklist.FieldInspectionType:
		return m.InspectionType()
	case checklist.FieldDescription:
		return m.Description()
	case checklist.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChecklistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checklist.FieldTitle:
		return m.OldTitle(ctx)
	case checklist.FieldInspectionType:
		return m.OldInspectionType(ctx)
	case checklist.FieldDescription:
		return m.OldDescription(ctx)
	case checklist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Checklist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChecklistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checklist.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case checklist.FieldInspectionType:
		v, ok := value.(checklist.InspectionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInspectionType(v)
		return nil
	case checklist.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case checklist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Checklist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChecklistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChecklistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChecklistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Checklist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChecklistMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checklist.FieldDescription) {
		fields = append(fields, checklist.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChecklistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChecklistMutation) ClearField(name string) error {
	switch name {
	case checklist.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Checklist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChecklistMutation) ResetField(name string) error {
	switch name {
	case checklist.FieldTitle:
		m.ResetTitle()
		return nil
	case checklist.FieldInspectionType:
		m.ResetInspectionType()
		return nil
	case checklist.FieldDescription:
		m.ResetDescription()
		return nil
	case checklist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Checklist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChecklistMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.elements != nil {
		edges = append(edges, checklist.EdgeElements)
	}
	if m.tasks != nil {
		edges = append(edges, checklist.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChecklistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checklist.EdgeElements:
		ids := make([]ent.Value, 0, len(m.elements))
		for id := range m.elements {
			ids = append(ids, id)
		}
		return ids
	case checklist.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChecklistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedelements != nil {
		edges = append(edges, checklist.EdgeElements)
	}
	if m.removedtasks != nil {
		edges = append(edges, checklist.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChecklistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case checklist.EdgeElements:
		ids := make([]ent.Value, 0, len(m.removedelements))
		for id := range m.removedelements {
			ids = append(ids, id)
		}
		return ids
	case checklist.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChecklistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedelements {
		edges = append(edges, checklist.EdgeElements)
	}
	if m.clearedtasks {
		edges = append(edges, checklist.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChecklistMutation) EdgeCleared(name string) bool {
	switch name {
	case checklist.EdgeElements:
		return m.clearedelements
	case checklist.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChecklistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Checklist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChecklistMutation) ResetEdge(name string) error {
	switch name {
	case checklist.EdgeElements:
		m.ResetElements()
		return nil
	case checklist.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Checklist edge %s", name)
}

// ChecklistElementMutation represents an operation that mutates the ChecklistElement nodes in the graph.
type ChecklistElementMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	order_index               *int
	addorder_index            *int
	clearedFields             map[string]struct{}
	checklist                 *int
	clearedchecklist          bool
	element_catalog           *int
	clearedelement_catalog    bool
	inspection_results        map[int]struct{}
	removedinspection_results map[int]struct{}
	clearedinspection_results bool
	done                      bool
	oldValue                  func(context.Context) (*ChecklistElement, error)
	predicates                []predicate.ChecklistElement
}

var _ ent.Mutation = (*ChecklistElementMutation)(nil)

// checklistelementOption allows management of the mutation configuration using functional options.
type checklistelementOption func(*ChecklistElementMutation)

// newChecklistElementMutation creates new mutation for the ChecklistElement entity.
func newChecklistElementMutation(c config, op Op, opts ...checklistelementOption) *ChecklistElementMutation {
	m := &ChecklistElementMutation{
		config:        c,
		op:            op,
		typ:           TypeChecklistElement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChecklistElementID sets the ID field of the mutation.
func withChecklistElementID(id int) checklistelementOption {
	return func(m *ChecklistElementMutation) {
		var (
			err   error
			once  sync.Once
			value *ChecklistElement
		)
		m.oldValue = func(ctx context.Context) (*ChecklistElement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChecklistElement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChecklistElement sets the old ChecklistElement of the mutation.
func withChecklistElement(node *ChecklistElement) checklistelementOption {
	return func(m *ChecklistElementMutation) {
		m.oldValue = func(context.Context) (*ChecklistElement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChecklistElementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChecklistElementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChecklistElementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChecklistElementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChecklistElement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetChecklistID sets the "checklist_id" field.
func (m *ChecklistElementMutation) SetChecklistID(i int) {
	m.checklist = &i
}

// ChecklistID returns the value of the "checklist_id" field in the mutation.
func (m *ChecklistElementMutation) ChecklistID() (r int, exists bool) {
	v := m.checklist
	if v == nil {
		return
	}
	return *v, true
}

// OldChecklistID returns the old "checklist_id" field's value of the ChecklistElement entity.
// If the ChecklistElement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChecklistElementMutation) OldChecklistID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecklistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecklistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecklistID: %w", err)
	}
	return oldValue.ChecklistID, nil
}

// ResetChecklistID resets all changes to the "checklist_id" field.
func (m *ChecklistElementMutation) ResetChecklistID() {
	m.checklist = nil
}

// SetElementID sets the "element_id" field.
func (m *ChecklistElementMutation) SetElementID(i int) {
	m.element_catalog = &i
}

// ElementID returns the value of the "element_id" field in the mutation.
func (m *ChecklistElementMutation) ElementID() (r int, exists bool) {
	v := m.element_catalog
	if v == nil {
		return
	}
	return *v, true
}

// OldElementID returns the old "element_id" field's value of the ChecklistElement entity.
// If the ChecklistElement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChecklistElementMutation) OldElementID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElementID: %w", err)
	}
	return oldValue.ElementID, nil
}

// ResetElementID resets all changes to the "element_id" field.
func (m *ChecklistElementMutation) ResetElementID() {
	m.element_catalog = nil
}

// SetOrderIndex sets the "order_index" field.
func (m *ChecklistElementMutation) SetOrderIndex(i int) {
	m.order_index = &i
	m.addorder_index = nil
}

// OrderIndex returns the value of the "order_index" field in the mutation.
func (m *ChecklistElementMutation) OrderIndex() (r int, exists bool) {
	v := m.order_index
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderIndex returns the old "order_index" field's value of the ChecklistElement entity.
// If the ChecklistElement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChecklistElementMutation) OldOrderIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderIndex: %w", err)
	}
	return oldValue.OrderIndex, nil
}

// AddOrderIndex adds i to the "order_index" field.
func (m *ChecklistElementMutation) AddOrderIndex(i int) {
	if m.addorder_index != nil {
		*m.addorder_index += i
	} else {
		m.addorder_index = &i
	}
}

// AddedOrderIndex returns the value that was added to the "order_index" field in this mutation.
func (m *ChecklistElementMutation) AddedOrderIndex() (r int, exists bool) {
	v := m.addorder_index
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderIndex clears the value of the "order_index" field.
func (m *ChecklistElementMutation) ClearOrderIndex() {
	m.order_index = nil
	m.addorder_index = nil
	m.clearedFields[checklistelement.FieldOrderIndex] = struct{}{}
}

// OrderIndexCleared returns if the "order_index" field was cleared in this mutation.
func (m *ChecklistElementMutation) OrderIndexCleared() bool {
	_, ok := m.clearedFields[checklistelement.FieldOrderIndex]
	return ok
}

// ResetOrderIndex resets all changes to the "order_index" field.
func (m *ChecklistElementMutation) ResetOrderIndex() {
	m.order_index = nil
	m.addorder_index = nil
	delete(m.clearedFields, checklistelement.FieldOrderIndex)
}

// ClearChecklist clears the "checklist" edge to the Checklist entity.
func (m *ChecklistElementMutation) ClearChecklist() {
	m.clearedchecklist = true
	m.clearedFields[checklistelement.FieldChecklistID] = struct{}{}
}

// ChecklistCleared reports if the "checklist" edge to the Checklist entity was cleared.
func (m *ChecklistElementMutation) ChecklistCleared() bool {
	return m.clearedchecklist
}

// ChecklistIDs returns the "checklist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChecklistID instead. It exists only for internal usage by the builders.
func (m *ChecklistElementMutation) ChecklistIDs() (ids []int) {
	if id := m.checklist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChecklist resets all changes to the "checklist" edge.
func (m *ChecklistElementMutation) ResetChecklist() {
	m.checklist = nil
	m.clearedchecklist = false
}

// SetElementCatalogID sets the "element_catalog" edge to the ElementCatalog entity by id.
func (m *ChecklistElementMutation) SetElementCatalogID(id int) {
	m.element_catalog = &id
}

// ClearElementCatalog clears the "element_catalog" edge to the ElementCatalog entity.
func (m *ChecklistElementMutation) ClearElementCatalog() {
	m.clearedelement_catalog = true
	m.clearedFields[checklistelement.FieldElementID] = struct{}{}
}

// ElementCatalogCleared reports if the "element_catalog" edge to the ElementCatalog entity was cleared.
func (m *ChecklistElementMutation) ElementCatalogCleared() bool {
	return m.clearedelement_catalog
}

// ElementCatalogID returns the "element_catalog" edge ID in the mutation.
func (m *ChecklistElementMutation) ElementCatalogID() (id int, exists bool) {
	if m.element_catalog != nil {
		return *m.element_catalog, true
	}
	return
}

// ElementCatalogIDs returns the "element_catalog" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElementCatalogID instead. It exists only for internal usage by the builders.
func (m *ChecklistElementMutation) ElementCatalogIDs() (ids []int) {
	if id := m.element_catalog; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElementCatalog resets all changes to the "element_catalog" edge.
func (m *ChecklistElementMutation) ResetElementCatalog() {
	m.element_catalog = nil
	m.clearedelement_catalog = false
}

// AddInspectionResultIDs adds the "inspection_results" edge to the InspectionResult entity by ids.
func (m *ChecklistElementMutation) AddInspectionResultIDs(ids ...int) {
	if m.inspection_results == nil {
		m.inspection_results = make(map[int]struct{})
	}
	for i := range ids {
		m.inspection_results[ids[i]] = struct{}{}
	}
}

// ClearInspectionResults clears the "inspection_results" edge to the InspectionResult entity.
func (m *ChecklistElementMutation) ClearInspectionResults() {
	m.clearedinspection_results = true
}

// InspectionResultsCleared reports if the "inspection_results" edge to the InspectionResult entity was cleared.
func (m *ChecklistElementMutation) InspectionResultsCleared() bool {
	return m.clearedinspection_results
}

// RemoveInspectionResultIDs removes the "inspection_results" edge to the InspectionResult entity by IDs.
func (m *ChecklistElementMutation) RemoveInspectionResultIDs(ids ...int) {
	if m.removedinspection_results == nil {
		m.removedinspection_results = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inspection_results, ids[i])
		m.removedinspection_results[ids[i]] = struct{}{}
	}
}

// RemovedInspectionResults returns the removed IDs of the "inspection_results" edge to the InspectionResult entity.
func (m *ChecklistElementMutation) RemovedInspectionResultsIDs() (ids []int) {
	for id := range m.removedinspection_results {
		ids = append(ids, id)
	}
	return
}

// InspectionResultsIDs returns the "inspection_results" edge IDs in the mutation.
func (m *ChecklistElementMutation) InspectionResultsIDs() (ids []int) {
	for id := range m.inspection_results {
		ids = append(ids, id)
	}
	return
}

// ResetInspectionResults resets all changes to the "inspection_results" edge.
func (m *ChecklistElementMutation) ResetInspectionResults() {
	m.inspection_results = nil
	m.clearedinspection_results = false
	m.removedinspection_results = nil
}

// Where appends a list predicates to the ChecklistElementMutation builder.
func (m *ChecklistElementMutation) Where(ps ...predicate.ChecklistElement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChecklistElementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChecklistElementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChecklistElement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChecklistElementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChecklistElementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChecklistElement).
func (m *ChecklistElementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChecklistElementMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.checklist != nil {
		fields = append(fields, checklistelement.FieldChecklistID)
	}
	if m.element_catalog != nil {
		fields = append(fields, checklistelement.FieldElementID)
	}
	if m.order_index != nil {
		fields = append(fields, checklistelement.FieldOrderIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChecklistElementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case checklistelement.FieldChecklistID:
		return m.ChecklistID()
	case checklistelement.FieldElementID:
		return m.ElementID()
	case checklistelement.FieldOrderIndex:
		return m.OrderIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChecklistElementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case checklistelement.FieldChecklistID:
		return m.OldChecklistID(ctx)
	case checklistelement.FieldElementID:
		return m.OldElementID(ctx)
	case checklistelement.FieldOrderIndex:
		return m.OldOrderIndex(ctx)
	}
	return nil, fmt.Errorf("unknown ChecklistElement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChecklistElementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case checklistelement.FieldChecklistID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecklistID(v)
		return nil
	case checklistelement.FieldElementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElementID(v)
		return nil
	case checklistelement.FieldOrderIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderIndex(v)
		return nil
	}
	return fmt.Errorf("unknown ChecklistElement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChecklistElementMutation) AddedFields() []string {
	var fields []string
	if m.addorder_index != nil {
		fields = append(fields, checklistelement.FieldOrderIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChecklistElementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case checklistelement.FieldOrderIndex:
		return m.AddedOrderIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChecklistElementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case checklistelement.FieldOrderIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderIndex(v)
		return nil
	}
	return fmt.Errorf("unknown ChecklistElement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChecklistElementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(checklistelement.FieldOrderIndex) {
		fields = append(fields, checklistelement.FieldOrderIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChecklistElementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChecklistElementMutation) ClearField(name string) error {
	switch name {
	case checklistelement.FieldOrderIndex:
		m.ClearOrderIndex()
		return nil
	}
	return fmt.Errorf("unknown ChecklistElement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChecklistElementMutation) ResetField(name string) error {
	switch name {
	case checklistelement.FieldChecklistID:
		m.ResetChecklistID()
		return nil
	case checklistelement.FieldElementID:
		m.ResetElementID()
		return nil
	case checklistelement.FieldOrderIndex:
		m.ResetOrderIndex()
		return nil
	}
	return fmt.Errorf("unknown ChecklistElement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChecklistElementMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.checklist != nil {
		edges = append(edges, checklistelement.EdgeChecklist)
	}
	if m.element_catalog != nil {
		edges = append(edges, checklistelement.EdgeElementCatalog)
	}
	if m.inspection_results != nil {
		edges = append(edges, checklistelement.EdgeInspectionResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChecklistElementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case checklistelement.EdgeChecklist:
		if id := m.checklist; id != nil {
			return []ent.Value{*id}
		}
	case checklistelement.EdgeElementCatalog:
		if id := m.element_catalog; id != nil {
			return []ent.Value{*id}
		}
	case checklistelement.EdgeInspectionResults:
		ids := make([]ent.Value, 0, len(m.inspection_results))
		for id := range m.inspection_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChecklistElementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinspection_results != nil {
		edges = append(edges, checklistelement.EdgeInspectionResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChecklistElementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case checklistelement.EdgeInspectionResults:
		ids := make([]ent.Value, 0, len(m.removedinspection_results))
		for id := range m.removedinspection_results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChecklistElementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchecklist {
		edges = append(edges, checklistelement.EdgeChecklist)
	}
	if m.clearedelement_catalog {
		edges = append(edges, checklistelement.EdgeElementCatalog)
	}
	if m.clearedinspection_results {
		edges = append(edges, checklistelement.EdgeInspectionResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChecklistElementMutation) EdgeCleared(name string) bool {
	switch name {
	case checklistelement.EdgeChecklist:
		return m.clearedchecklist
	case checklistelement.EdgeElementCatalog:
		return m.clearedelement_catalog
	case checklistelement.EdgeInspectionResults:
		return m.clearedinspection_results
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChecklistElementMutation) ClearEdge(name string) error {
	switch name {
	case checklistelement.EdgeChecklist:
		m.ClearChecklist()
		return nil
	case checklistelement.EdgeElementCatalog:
		m.ClearElementCatalog()
		return nil
	}
	return fmt.Errorf("unknown ChecklistElement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChecklistElementMutation) ResetEdge(name string) error {
	switch name {
	case checklistelement.EdgeChecklist:
		m.ResetChecklist()
		return nil
	case checklistelement.EdgeElementCatalog:
		m.ResetElementCatalog()
		return nil
	case checklistelement.EdgeInspectionResults:
		m.ResetInspectionResults()
		return nil
	}
	return fmt.Errorf("unknown ChecklistElement edge %s", name)
}

// DistrictMutation represents an operation that mutates the District nodes in the graph.
type DistrictMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	jkh_units        map[int]struct{}
	removedjkh_units map[int]struct{}
	clearedjkh_units bool
	buildings        map[int]struct{}
	removedbuildings map[int]struct{}
	clearedbuildings bool
	done             bool
	oldValue         func(context.Context) (*District, error)
	predicates       []predicate.District
}

var _ ent.Mutation = (*DistrictMutation)(nil)

// districtOption allows management of the mutation configuration using functional options.
type districtOption func(*DistrictMutation)

// newDistrictMutation creates new mutation for the District entity.
func newDistrictMutation(c config, op Op, opts ...districtOption) *DistrictMutation {
	m := &DistrictMutation{
		config:        c,
		op:            op,
		typ:           TypeDistrict,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDistrictID sets the ID field of the mutation.
func withDistrictID(id int) districtOption {
	return func(m *DistrictMutation) {
		var (
			err   error
			once  sync.Once
			value *District
		)
		m.oldValue = func(ctx context.Context) (*District, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().District.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDistrict sets the old District of the mutation.
func withDistrict(node *District) districtOption {
	return func(m *DistrictMutation) {
		m.oldValue = func(context.Context) (*District, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DistrictMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DistrictMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DistrictMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DistrictMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().District.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DistrictMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DistrictMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the District entity.
// If the District object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DistrictMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DistrictMutation) ResetName() {
	m.name = nil
}

// AddJkhUnitIDs adds the "jkh_units" edge to the JkhUnit entity by ids.
func (m *DistrictMutation) AddJkhUnitIDs(ids ...int) {
	if m.jkh_units == nil {
		m.jkh_units = make(map[int]struct{})
	}
	for i := range ids {
		m.jkh_units[ids[i]] = struct{}{}
	}
}

// ClearJkhUnits clears the "jkh_units" edge to the JkhUnit entity.
func (m *DistrictMutation) ClearJkhUnits() {
	m.clearedjkh_units = true
}

// JkhUnitsCleared reports if the "jkh_units" edge to the JkhUnit entity was cleared.
func (m *DistrictMutation) JkhUnitsCleared() bool {
	return m.clearedjkh_units
}

// RemoveJkhUnitIDs removes the "jkh_units" edge to the JkhUnit entity by IDs.
func (m *DistrictMutation) RemoveJkhUnitIDs(ids ...int) {
	if m.removedjkh_units == nil {
		m.removedjkh_units = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jkh_units, ids[i])
		m.removedjkh_units[ids[i]] = struct{}{}
	}
}

// RemovedJkhUnits returns the removed IDs of the "jkh_units" edge to the JkhUnit entity.
func (m *DistrictMutation) RemovedJkhUnitsIDs() (ids []int) {
	for id := range m.removedjkh_units {
		ids = append(ids, id)
	}
	return
}

// JkhUnitsIDs returns the "jkh_units" edge IDs in the mutation.
func (m *DistrictMutation) JkhUnitsIDs() (ids []int) {
	for id := range m.jkh_units {
		ids = append(ids, id)
	}
	return
}

// ResetJkhUnits resets all changes to the "jkh_units" edge.
func (m *DistrictMutation) ResetJkhUnits() {
	m.jkh_units = nil
	m.clearedjkh_units = false
	m.removedjkh_units = nil
}

// AddBuildingIDs adds the "buildings" edge to the Building entity by ids.
func (m *DistrictMutation) AddBuildingIDs(ids ...int) {
	if m.buildings == nil {
		m.buildings = make(map[int]struct{})
	}
	for i := range ids {
		m.buildings[ids[i]] = struct{}{}
	}
}

// ClearBuildings clears the "buildings" edge to the Building entity.
func (m *DistrictMutation) ClearBuildings() {
	m.clearedbuildings = true
}

// BuildingsCleared reports if the "buildings" edge to the Building entity was cleared.
func (m *DistrictMutation) BuildingsCleared() bool {
	return m.clearedbuildings
}

// RemoveBuildingIDs removes the "buildings" edge to the Building entity by IDs.
func (m *DistrictMutation) RemoveBuildingIDs(ids ...int) {
	if m.removedbuildings == nil {
		m.removedbuildings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.buildings, ids[i])
		m.removedbuildings[ids[i]] = struct{}{}
	}
}

// RemovedBuildings returns the removed IDs of the "buildings" edge to the Building entity.
func (m *DistrictMutation) RemovedBuildingsIDs() (ids []int) {
	for id := range m.removedbuildings {
		ids = append(ids, id)
	}
	return
}

// BuildingsIDs returns the "buildings" edge IDs in the mutation.
func (m *DistrictMutation) BuildingsIDs() (ids []int) {
	for id := range m.buildings {
		ids = append(ids, id)
	}
	return
}

// ResetBuildings resets all changes to the "buildings" edge.
func (m *DistrictMutation) ResetBuildings() {
	m.buildings = nil
	m.clearedbuildings = false
	m.removedbuildings = nil
}

// Where appends a list predicates to the DistrictMutation builder.
func (m *DistrictMutation) Where(ps ...predicate.District) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DistrictMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DistrictMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.District, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DistrictMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DistrictMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (District).
func (m *DistrictMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DistrictMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, district.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DistrictMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case district.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DistrictMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case district.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown District field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) SetField(name string, value ent.Value) error {
	switch name {
	case district.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DistrictMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DistrictMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DistrictMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown District numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DistrictMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DistrictMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DistrictMutation) ClearField(name string) error {
	return fmt.Errorf("unknown District nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DistrictMutation) ResetField(name string) error {
	switch name {
	case district.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown District field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DistrictMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.jkh_units != nil {
		edges = append(edges, district.EdgeJkhUnits)
	}
	if m.buildings != nil {
		edges = append(edges, district.EdgeBuildings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DistrictMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeJkhUnits:
		ids := make([]ent.Value, 0, len(m.jkh_units))
		for id := range m.jkh_units {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeBuildings:
		ids := make([]ent.Value, 0, len(m.buildings))
		for id := range m.buildings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DistrictMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedjkh_units != nil {
		edges = append(edges, district.EdgeJkhUnits)
	}
	if m.removedbuildings != nil {
		edges = append(edges, district.EdgeBuildings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DistrictMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case district.EdgeJkhUnits:
		ids := make([]ent.Value, 0, len(m.removedjkh_units))
		for id := range m.removedjkh_units {
			ids = append(ids, id)
		}
		return ids
	case district.EdgeBuildings:
		ids := make([]ent.Value, 0, len(m.removedbuildings))
		for id := range m.removedbuildings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DistrictMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjkh_units {
		edges = append(edges, district.EdgeJkhUnits)
	}
	if m.clearedbuildings {
		edges = append(edges, district.EdgeBuildings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DistrictMutation) EdgeCleared(name string) bool {
	switch name {
	case district.EdgeJkhUnits:
		return m.clearedjkh_units
	case district.EdgeBuildings:
		return m.clearedbuildings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DistrictMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown District unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DistrictMutation) ResetEdge(name string) error {
	switch name {
	case district.EdgeJkhUnits:
		m.ResetJkhUnits()
		return nil
	case district.EdgeBuildings:
		m.ResetBuildings()
		return nil
	}
	return fmt.Errorf("unknown District edge %s", name)
}

// ElementCatalogMutation represents an operation that mutates the ElementCatalog nodes in the graph.
type ElementCatalogMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	category                  *string
	clearedFields             map[string]struct{}
	checklist_elements        map[int]struct{}
	removedchecklist_elements map[int]struct{}
	clearedchecklist_elements bool
	done                      bool
	oldValue                  func(context.Context) (*ElementCatalog, error)
	predicates                []predicate.ElementCatalog
}

var _ ent.Mutation = (*ElementCatalogMutation)(nil)

// elementcatalogOption allows management of the mutation configuration using functional options.
type elementcatalogOption func(*ElementCatalogMutation)

// newElementCatalogMutation creates new mutation for the ElementCatalog entity.
func newElementCatalogMutation(c config, op Op, opts ...elementcatalogOption) *ElementCatalogMutation {
	m := &ElementCatalogMutation{
		config:        c,
		op:            op,
		typ:           TypeElementCatalog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withElementCatalogID sets the ID field of the mutation.
func withElementCatalogID(id int) elementcatalogOption {
	return func(m *ElementCatalogMutation) {
		var (
			err   error
			once  sync.Once
			value *ElementCatalog
		)
		m.oldValue = func(ctx context.Context) (*ElementCatalog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ElementCatalog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withElementCatalog sets the old ElementCatalog of the mutation.
func withElementCatalog(node *ElementCatalog) elementcatalogOption {
	return func(m *ElementCatalogMutation) {
		m.oldValue = func(context.Context) (*ElementCatalog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ElementCatalogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ElementCatalogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ElementCatalogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ElementCatalogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ElementCatalog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ElementCatalogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ElementCatalogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ElementCatalog entity.
// If the ElementCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElementCatalogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ElementCatalogMutation) ResetName() {
	m.name = nil
}

// SetCategory sets the "category" field.
func (m *ElementCatalogMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *ElementCatalogMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the ElementCatalog entity.
// If the ElementCatalog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElementCatalogMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ClearCategory clears the value of the "category" field.
func (m *ElementCatalogMutation) ClearCategory() {
	m.category = nil
	m.clearedFields[elementcatalog.FieldCategory] = struct{}{}
}

// CategoryCleared returns if the "category" field was cleared in this mutation.
func (m *ElementCatalogMutation) CategoryCleared() bool {
	_, ok := m.clearedFields[elementcatalog.FieldCategory]
	return ok
}

// ResetCategory resets all changes to the "category" field.
func (m *ElementCatalogMutation) ResetCategory() {
	m.category = nil
	delete(m.clearedFields, elementcatalog.FieldCategory)
}

// AddChecklistElementIDs adds the "checklist_elements" edge to the ChecklistElement entity by ids.
func (m *ElementCatalogMutation) AddChecklistElementIDs(ids ...int) {
	if m.checklist_elements == nil {
		m.checklist_elements = make(map[int]struct{})
	}
	for i := range ids {
		m.checklist_elements[ids[i]] = struct{}{}
	}
}

// ClearChecklistElements clears the "checklist_elements" edge to the ChecklistElement entity.
func (m *ElementCatalogMutation) ClearChecklistElements() {
	m.clearedchecklist_elements = true
}

// ChecklistElementsCleared reports if the "checklist_elements" edge to the ChecklistElement entity was cleared.
func (m *ElementCatalogMutation) ChecklistElementsCleared() bool {
	return m.clearedchecklist_elements
}

// RemoveChecklistElementIDs removes the "checklist_elements" edge to the ChecklistElement entity by IDs.
func (m *ElementCatalogMutation) RemoveChecklistElementIDs(ids ...int) {
	if m.removedchecklist_elements == nil {
		m.removedchecklist_elements = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.checklist_elements, ids[i])
		m.removedchecklist_elements[ids[i]] = struct{}{}
	}
}

// RemovedChecklistElements returns the removed IDs of the "checklist_elements" edge to the ChecklistElement entity.
func (m *ElementCatalogMutation) RemovedChecklistElementsIDs() (ids []int) {
	for id := range m.removedchecklist_elements {
		ids = append(ids, id)
	}
	return
}

// ChecklistElementsIDs returns the "checklist_elements" edge IDs in the mutation.
func (m *ElementCatalogMutation) ChecklistElementsIDs() (ids []int) {
	for id := range m.checklist_elements {
		ids = append(ids, id)
	}
	return
}

// ResetChecklistElements resets all changes to the "checklist_elements" edge.
func (m *ElementCatalogMutation) ResetChecklistElements() {
	m.checklist_elements = nil
	m.clearedchecklist_elements = false
	m.removedchecklist_elements = nil
}

// Where appends a list predicates to the ElementCatalogMutation builder.
func (m *ElementCatalogMutation) Where(ps ...predicate.ElementCatalog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ElementCatalogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ElementCatalogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ElementCatalog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ElementCatalogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ElementCatalogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ElementCatalog).
func (m *ElementCatalogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ElementCatalogMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, elementcatalog.FieldName)
	}
	if m.category != nil {
		fields = append(fields, elementcatalog.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ElementCatalogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case elementcatalog.FieldName:
		return m.Name()
	case elementcatalog.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ElementCatalogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case elementcatalog.FieldName:
		return m.OldName(ctx)
	case elementcatalog.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown ElementCatalog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ElementCatalogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case elementcatalog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case elementcatalog.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown ElementCatalog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ElementCatalogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ElementCatalogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ElementCatalogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ElementCatalog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ElementCatalogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(elementcatalog.FieldCategory) {
		fields = append(fields, elementcatalog.FieldCategory)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ElementCatalogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ElementCatalogMutation) ClearField(name string) error {
	switch name {
	case elementcatalog.FieldCategory:
		m.ClearCategory()
		return nil
	}
	return fmt.Errorf("unknown ElementCatalog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ElementCatalogMutation) ResetField(name string) error {
	switch name {
	case elementcatalog.FieldName:
		m.ResetName()
		return nil
	case elementcatalog.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown ElementCatalog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ElementCatalogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.checklist_elements != nil {
		edges = append(edges, elementcatalog.EdgeChecklistElements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ElementCatalogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case elementcatalog.EdgeChecklistElements:
		ids := make([]ent.Value, 0, len(m.checklist_elements))
		for id := range m.checklist_elements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ElementCatalogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedchecklist_elements != nil {
		edges = append(edges, elementcatalog.EdgeChecklistElements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ElementCatalogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case elementcatalog.EdgeChecklistElements:
		ids := make([]ent.Value, 0, len(m.removedchecklist_elements))
		for id := range m.removedchecklist_elements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ElementCatalogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchecklist_elements {
		edges = append(edges, elementcatalog.EdgeChecklistElements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ElementCatalogMutation) EdgeCleared(name string) bool {
	switch name {
	case elementcatalog.EdgeChecklistElements:
		return m.clearedchecklist_elements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ElementCatalogMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ElementCatalog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ElementCatalogMutation) ResetEdge(name string) error {
	switch name {
	case elementcatalog.EdgeChecklistElements:
		m.ResetChecklistElements()
		return nil
	}
	return fmt.Errorf("unknown ElementCatalog edge %s", name)
}

// InspectionActMutation represents an operation that mutates the InspectionAct nodes in the graph.
type InspectionActMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	approved_at   *time.Time
	status        *string
	conclusion    *string
	document_path *string
	clearedFields map[string]struct{}
	task          *int
	clearedtask   bool
	done          bool
	oldValue      func(context.Context) (*InspectionAct, error)
	predicates    []predicate.InspectionAct
}

var _ ent.Mutation = (*InspectionActMutation)(nil)

// inspectionactOption allows management of the mutation configuration using functional options.
type inspectionactOption func(*InspectionActMutation)

// newInspectionActMutation creates new mutation for the InspectionAct entity.
func newInspectionActMutation(c config, op Op, opts ...inspectionactOption) *InspectionActMutation {
	m := &InspectionActMutation{
		config:        c,
		op:            op,
		typ:           TypeInspectionAct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInspectionActID sets the ID field of the mutation.
func withInspectionActID(id int) inspectionactOption {
	return func(m *InspectionActMutation) {
		var (
			err   error
			once  sync.Once
			value *InspectionAct
		)
		m.oldValue = func(ctx context.Context) (*InspectionAct, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InspectionAct.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInspectionAct sets the old InspectionAct of the mutation.
func withInspectionAct(node *InspectionAct) inspectionactOption {
	return func(m *InspectionActMutation) {
		m.oldValue = func(context.Context) (*InspectionAct, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InspectionActMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InspectionActMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InspectionActMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InspectionActMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InspectionAct.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *InspectionActMutation) SetTaskID(i int) {
	m.task = &i
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *InspectionActMutation) TaskID() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the InspectionAct entity.
// If the InspectionAct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionActMutation) OldTaskID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *InspectionActMutation) ResetTaskID() {
	m.task = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *InspectionActMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InspectionActMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InspectionAct entity.
// If the InspectionAct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionActMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InspectionActMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetApprovedAt sets the "approved_at" field.
func (m *InspectionActMutation) SetApprovedAt(t time.Time) {
	m.approved_at = &t
}

// ApprovedAt returns the value of the "approved_at" field in the mutation.
func (m *InspectionActMutation) ApprovedAt() (r time.Time, exists bool) {
	v := m.approved_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovedAt returns the old "approved_at" field's value of the InspectionAct entity.
// If the InspectionAct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionActMutation) OldApprovedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovedAt: %w", err)
	}
	return oldValue.ApprovedAt, nil
}

// ClearApprovedAt clears the value of the "approved_at" field.
func (m *InspectionActMutation) ClearApprovedAt() {
	m.approved_at = nil
	m.clearedFields[inspectionact.FieldApprovedAt] = struct{}{}
}

// ApprovedAtCleared returns if the "approved_at" field was cleared in this mutation.
func (m *InspectionActMutation) ApprovedAtCleared() bool {
	_, ok := m.clearedFields[inspectionact.FieldApprovedAt]
	return ok
}

// ResetApprovedAt resets all changes to the "approved_at" field.
func (m *InspectionActMutation) ResetApprovedAt() {
	m.approved_at = nil
	delete(m.clearedFields, inspectionact.FieldApprovedAt)
}

// SetStatus sets the "status" field.
func (m *InspectionActMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InspectionActMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InspectionAct entity.
// If the InspectionAct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionActMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InspectionActMutation) ResetStatus() {
	m.status = nil
}

// SetConclusion sets the "conclusion" field.
func (m *InspectionActMutation) SetConclusion(s string) {
	m.conclusion = &s
}

// Conclusion returns the value of the "conclusion" field in the mutation.
func (m *InspectionActMutation) Conclusion() (r string, exists bool) {
	v := m.conclusion
	if v == nil {
		return
	}
	return *v, true
}

// OldConclusion returns the old "conclusion" field's value of the InspectionAct entity.
// If the InspectionAct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionActMutation) OldConclusion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConclusion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConclusion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConclusion: %w", err)
	}
	return oldValue.Conclusion, nil
}

// ClearConclusion clears the value of the "conclusion" field.
func (m *InspectionActMutation) ClearConclusion() {
	m.conclusion = nil
	m.clearedFields[inspectionact.FieldConclusion] = struct{}{}
}

// ConclusionCleared returns if the "conclusion" field was cleared in this mutation.
func (m *InspectionActMutation) ConclusionCleared() bool {
	_, ok := m.clearedFields[inspectionact.FieldConclusion]
	return ok
}

// ResetConclusion resets all changes to the "conclusion" field.
func (m *InspectionActMutation) ResetConclusion() {
	m.conclusion = nil
	delete(m.clearedFields, inspectionact.FieldConclusion)
}

// SetDocumentPath sets the "document_path" field.
func (m *InspectionActMutation) SetDocumentPath(s string) {
	m.document_path = &s
}

// DocumentPath returns the value of the "document_path" field in the mutation.
func (m *InspectionActMutation) DocumentPath() (r string, exists bool) {
	v := m.document_path
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentPath returns the old "document_path" field's value of the InspectionAct entity.
// If the InspectionAct object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionActMutation) OldDocumentPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentPath: %w", err)
	}
	return oldValue.DocumentPath, nil
}

// ClearDocumentPath clears the value of the "document_path" field.
func (m *InspectionActMutation) ClearDocumentPath() {
	m.document_path = nil
	m.clearedFields[inspectionact.FieldDocumentPath] = struct{}{}
}

// DocumentPathCleared returns if the "document_path" field was cleared in this mutation.
func (m *InspectionActMutation) DocumentPathCleared() bool {
	_, ok := m.clearedFields[inspectionact.FieldDocumentPath]
	return ok
}

// ResetDocumentPath resets all changes to the "document_path" field.
func (m *InspectionActMutation) ResetDocumentPath() {
	m.document_path = nil
	delete(m.clearedFields, inspectionact.FieldDocumentPath)
}

// ClearTask clears the "task" edge to the Task entity.
func (m *InspectionActMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[inspectionact.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *InspectionActMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *InspectionActMutation) TaskIDs() (ids []int) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *InspectionActMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// Where appends a list predicates to the InspectionActMutation builder.
func (m *InspectionActMutation) Where(ps ...predicate.InspectionAct) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InspectionActMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InspectionActMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InspectionAct, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InspectionActMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InspectionActMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InspectionAct).
func (m *InspectionActMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InspectionActMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.task != nil {
		fields = append(fields, inspectionact.FieldTaskID)
	}
	if m.created_at != nil {
		fields = append(fields, inspectionact.FieldCreatedAt)
	}
	if m.approved_at != nil {
		fields = append(fields, inspectionact.FieldApprovedAt)
	}
	if m.status != nil {
		fields = append(fields, inspectionact.FieldStatus)
	}
	if m.conclusion != nil {
		fields = append(fields, inspectionact.FieldConclusion)
	}
	if m.document_path != nil {
		fields = append(fields, inspectionact.FieldDocumentPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InspectionActMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inspectionact.FieldTaskID:
		return m.TaskID()
	case inspectionact.FieldCreatedAt:
		return m.CreatedAt()
	case inspectionact.FieldApprovedAt:
		return m.ApprovedAt()
	case inspectionact.FieldStatus:
		return m.Status()
	case inspectionact.FieldConclusion:
		return m.Conclusion()
	case inspectionact.FieldDocumentPath:
		return m.DocumentPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InspectionActMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inspectionact.FieldTaskID:
		return m.OldTaskID(ctx)
	case inspectionact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inspectionact.FieldApprovedAt:
		return m.OldApprovedAt(ctx)
	case inspectionact.FieldStatus:
		return m.OldStatus(ctx)
	case inspectionact.FieldConclusion:
		return m.OldConclusion(ctx)
	case inspectionact.FieldDocumentPath:
		return m.OldDocumentPath(ctx)
	}
	return nil, fmt.Errorf("unknown InspectionAct field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InspectionActMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inspectionact.FieldTaskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case inspectionact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inspectionact.FieldApprovedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovedAt(v)
		return nil
	case inspectionact.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case inspectionact.FieldConclusion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConclusion(v)
		return nil
	case inspectionact.FieldDocumentPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentPath(v)
		return nil
	}
	return fmt.Errorf("unknown InspectionAct field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InspectionActMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InspectionActMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InspectionActMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InspectionAct numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InspectionActMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inspectionact.FieldApprovedAt) {
		fields = append(fields, inspectionact.FieldApprovedAt)
	}
	if m.FieldCleared(inspectionact.FieldConclusion) {
		fields = append(fields, inspectionact.FieldConclusion)
	}
	if m.FieldCleared(inspectionact.FieldDocumentPath) {
		fields = append(fields, inspectionact.FieldDocumentPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InspectionActMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InspectionActMutation) ClearField(name string) error {
	switch name {
	case inspectionact.FieldApprovedAt:
		m.ClearApprovedAt()
		return nil
	case inspectionact.FieldConclusion:
		m.ClearConclusion()
		return nil
	case inspectionact.FieldDocumentPath:
		m.ClearDocumentPath()
		return nil
	}
	return fmt.Errorf("unknown InspectionAct nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InspectionActMutation) ResetField(name string) error {
	switch name {
	case inspectionact.FieldTaskID:
		m.ResetTaskID()
		return nil
	case inspectionact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inspectionact.FieldApprovedAt:
		m.ResetApprovedAt()
		return nil
	case inspectionact.FieldStatus:
		m.ResetStatus()
		return nil
	case inspectionact.FieldConclusion:
		m.ResetConclusion()
		return nil
	case inspectionact.FieldDocumentPath:
		m.ResetDocumentPath()
		return nil
	}
	return fmt.Errorf("unknown InspectionAct field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InspectionActMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.task != nil {
		edges = append(edges, inspectionact.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InspectionActMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inspectionact.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InspectionActMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InspectionActMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InspectionActMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtask {
		edges = append(edges, inspectionact.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InspectionActMutation) EdgeCleared(name string) bool {
	switch name {
	case inspectionact.EdgeTask:
		return m.clearedtask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InspectionActMutation) ClearEdge(name string) error {
	switch name {
	case inspectionact.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown InspectionAct unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InspectionActMutation) ResetEdge(name string) error {
	switch name {
	case inspectionact.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown InspectionAct edge %s", name)
}

// InspectionResultMutation represents an operation that mutates the InspectionResult nodes in the graph.
type InspectionResultMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	condition_status         *inspectionresult.ConditionStatus
	comment                  *string
	created_at               *time.Time
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	task                     *int
	clearedtask              bool
	checklist_element        *int
	clearedchecklist_element bool
	done                     bool
	oldValue                 func(context.Context) (*InspectionResult, error)
	predicates               []predicate.InspectionResult
}

var _ ent.Mutation = (*InspectionResultMutation)(nil)

// inspectionresultOption allows management of the mutation configuration using functional options.
type inspectionresultOption func(*InspectionResultMutation)

// newInspectionResultMutation creates new mutation for the InspectionResult entity.
func newInspectionResultMutation(c config, op Op, opts ...inspectionresultOption) *InspectionResultMutation {
	m := &InspectionResultMutation{
		config:        c,
		op:            op,
		typ:           TypeInspectionResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInspectionResultID sets the ID field of the mutation.
func withInspectionResultID(id int) inspectionresultOption {
	return func(m *InspectionResultMutation) {
		var (
			err   error
			once  sync.Once
			value *InspectionResult
		)
		m.oldValue = func(ctx context.Context) (*InspectionResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InspectionResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInspectionResult sets the old InspectionResult of the mutation.
func withInspectionResult(node *InspectionResult) inspectionresultOption {
	return func(m *InspectionResultMutation) {
		m.oldValue = func(context.Context) (*InspectionResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InspectionResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InspectionResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InspectionResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InspectionResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InspectionResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *InspectionResultMutation) SetTaskID(i int) {
	m.task = &i
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *InspectionResultMutation) TaskID() (r int, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the InspectionResult entity.
// If the InspectionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionResultMutation) OldTaskID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *InspectionResultMutation) ResetTaskID() {
	m.task = nil
}

// SetChecklistElementID sets the "checklist_element_id" field.
func (m *InspectionResultMutation) SetChecklistElementID(i int) {
	m.checklist_element = &i
}

// ChecklistElementID returns the value of the "checklist_element_id" field in the mutation.
func (m *InspectionResultMutation) ChecklistElementID() (r int, exists bool) {
	v := m.checklist_element
	if v == nil {
		return
	}
	return *v, true
}

// OldChecklistElementID returns the old "checklist_element_id" field's value of the InspectionResult entity.
// If the InspectionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionResultMutation) OldChecklistElementID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecklistElementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecklistElementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecklistElementID: %w", err)
	}
	return oldValue.ChecklistElementID, nil
}

// ResetChecklistElementID resets all changes to the "checklist_element_id" field.
func (m *InspectionResultMutation) ResetChecklistElementID() {
	m.checklist_element = nil
}

// SetConditionStatus sets the "condition_status" field.
func (m *InspectionResultMutation) SetConditionStatus(is inspectionresult.ConditionStatus) {
	m.condition_status = &is
}

// ConditionStatus returns the value of the "condition_status" field in the mutation.
func (m *InspectionResultMutation) ConditionStatus() (r inspectionresult.ConditionStatus, exists bool) {
	v := m.condition_status
	if v == nil {
		return
	}
	return *v, true
}

// OldConditionStatus returns the old "condition_status" field's value of the InspectionResult entity.
// If the InspectionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionResultMutation) OldConditionStatus(ctx context.Context) (v inspectionresult.ConditionStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditionStatus: %w", err)
	}
	return oldValue.ConditionStatus, nil
}

// ResetConditionStatus resets all changes to the "condition_status" field.
func (m *InspectionResultMutation) ResetConditionStatus() {
	m.condition_status = nil
}

// SetComment sets the "comment" field.
func (m *InspectionResultMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *InspectionResultMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the InspectionResult entity.
// If the InspectionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionResultMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *InspectionResultMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[inspectionresult.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *InspectionResultMutation) CommentCleared() bool {
	_, ok := m.clearedFields[inspectionresult.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *InspectionResultMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, inspectionresult.FieldComment)
}

// SetCreatedAt sets the "created_at" field.
func (m *InspectionResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InspectionResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InspectionResult entity.
// If the InspectionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InspectionResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InspectionResultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InspectionResultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InspectionResult entity.
// If the InspectionResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectionResultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InspectionResultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *InspectionResultMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[inspectionresult.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *InspectionResultMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *InspectionResultMutation) TaskIDs() (ids []int) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *InspectionResultMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearChecklistElement clears the "checklist_element" edge to the ChecklistElement entity.
func (m *InspectionResultMutation) ClearChecklistElement() {
	m.clearedchecklist_element = true
	m.clearedFields[inspectionresult.FieldChecklistElementID] = struct{}{}
}

// ChecklistElementCleared reports if the "checklist_element" edge to the ChecklistElement entity was cleared.
func (m *InspectionResultMutation) ChecklistElementCleared() bool {
	return m.clearedchecklist_element
}

// ChecklistElementIDs returns the "checklist_element" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChecklistElementID instead. It exists only for internal usage by the builders.
func (m *InspectionResultMutation) ChecklistElementIDs() (ids []int) {
	if id := m.checklist_element; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChecklistElement resets all changes to the "checklist_element" edge.
func (m *InspectionResultMutation) ResetChecklistElement() {
	m.checklist_element = nil
	m.clearedchecklist_element = false
}

// Where appends a list predicates to the InspectionResultMutation builder.
func (m *InspectionResultMutation) Where(ps ...predicate.InspectionResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InspectionResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InspectionResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InspectionResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InspectionResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InspectionResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InspectionResult).
func (m *InspectionResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InspectionResultMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.task != nil {
		fields = append(fields, inspectionresult.FieldTaskID)
	}
	if m.checklist_element != nil {
		fields = append(fields, inspectionresult.FieldChecklistElementID)
	}
	if m.condition_status != nil {
		fields = append(fields, inspectionresult.FieldConditionStatus)
	}
	if m.comment != nil {
		fields = append(fields, inspectionresult.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, inspectionresult.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inspectionresult.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InspectionResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inspectionresult.FieldTaskID:
		return m.TaskID()
	case inspectionresult.FieldChecklistElementID:
		return m.ChecklistElementID()
	case inspectionresult.FieldConditionStatus:
		return m.ConditionStatus()
	case inspectionresult.FieldComment:
		return m.Comment()
	case inspectionresult.FieldCreatedAt:
		return m.CreatedAt()
	case inspectionresult.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InspectionResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inspectionresult.FieldTaskID:
		return m.OldTaskID(ctx)
	case inspectionresult.FieldChecklistElementID:
		return m.OldChecklistElementID(ctx)
	case inspectionresult.FieldConditionStatus:
		return m.OldConditionStatus(ctx)
	case inspectionresult.FieldComment:
		return m.OldComment(ctx)
	case inspectionresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inspectionresult.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InspectionResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InspectionResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inspectionresult.FieldTaskID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case inspectionresult.FieldChecklistElementID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecklistElementID(v)
		return nil
	case inspectionresult.FieldConditionStatus:
		v, ok := value.(inspectionresult.ConditionStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditionStatus(v)
		return nil
	case inspectionresult.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case inspectionresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inspectionresult.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InspectionResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InspectionResultMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InspectionResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InspectionResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InspectionResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InspectionResultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inspectionresult.FieldComment) {
		fields = append(fields, inspectionresult.FieldComment)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InspectionResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InspectionResultMutation) ClearField(name string) error {
	switch name {
	case inspectionresult.FieldComment:
		m.ClearComment()
		return nil
	}
	return fmt.Errorf("unknown InspectionResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InspectionResultMutation) ResetField(name string) error {
	switch name {
	case inspectionresult.FieldTaskID:
		m.ResetTaskID()
		return nil
	case inspectionresult.FieldChecklistElementID:
		m.ResetChecklistElementID()
		return nil
	case inspectionresult.FieldConditionStatus:
		m.ResetConditionStatus()
		return nil
	case inspectionresult.FieldComment:
		m.ResetComment()
		return nil
	case inspectionresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inspectionresult.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown InspectionResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InspectionResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, inspectionresult.EdgeTask)
	}
	if m.checklist_element != nil {
		edges = append(edges, inspectionresult.EdgeChecklistElement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InspectionResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inspectionresult.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case inspectionresult.EdgeChecklistElement:
		if id := m.checklist_element; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InspectionResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InspectionResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InspectionResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, inspectionresult.EdgeTask)
	}
	if m.clearedchecklist_element {
		edges = append(edges, inspectionresult.EdgeChecklistElement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InspectionResultMutation) EdgeCleared(name string) bool {
	switch name {
	case inspectionresult.EdgeTask:
		return m.clearedtask
	case inspectionresult.EdgeChecklistElement:
		return m.clearedchecklist_element
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InspectionResultMutation) ClearEdge(name string) error {
	switch name {
	case inspectionresult.EdgeTask:
		m.ClearTask()
		return nil
	case inspectionresult.EdgeChecklistElement:
		m.ClearChecklistElement()
		return nil
	}
	return fmt.Errorf("unknown InspectionResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InspectionResultMutation) ResetEdge(name string) error {
	switch name {
	case inspectionresult.EdgeTask:
		m.ResetTask()
		return nil
	case inspectionresult.EdgeChecklistElement:
		m.ResetChecklistElement()
		return nil
	}
	return fmt.Errorf("unknown InspectionResult edge %s", name)
}

// InspectorUnitMutation represents an operation that mutates the InspectorUnit nodes in the graph.
type InspectorUnitMutation struct {
	config
	op               Op
	typ              string
	id               *int
	clearedFields    map[string]struct{}
	inspector        *int
	clearedinspector bool
	jkh_unit         *int
	clearedjkh_unit  bool
	done             bool
	oldValue         func(context.Context) (*InspectorUnit, error)
	predicates       []predicate.InspectorUnit
}

var _ ent.Mutation = (*InspectorUnitMutation)(nil)

// inspectorunitOption allows management of the mutation configuration using functional options.
type inspectorunitOption func(*InspectorUnitMutation)

// newInspectorUnitMutation creates new mutation for the InspectorUnit entity.
func newInspectorUnitMutation(c config, op Op, opts ...inspectorunitOption) *InspectorUnitMutation {
	m := &InspectorUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeInspectorUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInspectorUnitID sets the ID field of the mutation.
func withInspectorUnitID(id int) inspectorunitOption {
	return func(m *InspectorUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *InspectorUnit
		)
		m.oldValue = func(ctx context.Context) (*InspectorUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InspectorUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInspectorUnit sets the old InspectorUnit of the mutation.
func withInspectorUnit(node *InspectorUnit) inspectorunitOption {
	return func(m *InspectorUnitMutation) {
		m.oldValue = func(context.Context) (*InspectorUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InspectorUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InspectorUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InspectorUnitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InspectorUnitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InspectorUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *InspectorUnitMutation) SetUserID(i int) {
	m.inspector = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InspectorUnitMutation) UserID() (r int, exists bool) {
	v := m.inspector
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InspectorUnit entity.
// If the InspectorUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectorUnitMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InspectorUnitMutation) ResetUserID() {
	m.inspector = nil
}

// SetJkhUnitID sets the "jkh_unit_id" field.
func (m *InspectorUnitMutation) SetJkhUnitID(i int) {
	m.jkh_unit = &i
}

// JkhUnitID returns the value of the "jkh_unit_id" field in the mutation.
func (m *InspectorUnitMutation) JkhUnitID() (r int, exists bool) {
	v := m.jkh_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldJkhUnitID returns the old "jkh_unit_id" field's value of the InspectorUnit entity.
// If the InspectorUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InspectorUnitMutation) OldJkhUnitID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJkhUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJkhUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJkhUnitID: %w", err)
	}
	return oldValue.JkhUnitID, nil
}

// ResetJkhUnitID resets all changes to the "jkh_unit_id" field.
func (m *InspectorUnitMutation) ResetJkhUnitID() {
	m.jkh_unit = nil
}

// SetInspectorID sets the "inspector" edge to the User entity by id.
func (m *InspectorUnitMutation) SetInspectorID(id int) {
	m.inspector = &id
}

// ClearInspector clears the "inspector" edge to the User entity.
func (m *InspectorUnitMutation) ClearInspector() {
	m.clearedinspector = true
	m.clearedFields[inspectorunit.FieldUserID] = struct{}{}
}

// InspectorCleared reports if the "inspector" edge to the User entity was cleared.
func (m *InspectorUnitMutation) InspectorCleared() bool {
	return m.clearedinspector
}

// InspectorID returns the "inspector" edge ID in the mutation.
func (m *InspectorUnitMutation) InspectorID() (id int, exists bool) {
	if m.inspector != nil {
		return *m.inspector, true
	}
	return
}

// InspectorIDs returns the "inspector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InspectorID instead. It exists only for internal usage by the builders.
func (m *InspectorUnitMutation) InspectorIDs() (ids []int) {
	if id := m.inspector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInspector resets all changes to the "inspector" edge.
func (m *InspectorUnitMutation) ResetInspector() {
	m.inspector = nil
	m.clearedinspector = false
}

// ClearJkhUnit clears the "jkh_unit" edge to the JkhUnit entity.
func (m *InspectorUnitMutation) ClearJkhUnit() {
	m.clearedjkh_unit = true
	m.clearedFields[inspectorunit.FieldJkhUnitID] = struct{}{}
}

// JkhUnitCleared reports if the "jkh_unit" edge to the JkhUnit entity was cleared.
func (m *InspectorUnitMutation) JkhUnitCleared() bool {
	return m.clearedjkh_unit
}

// JkhUnitIDs returns the "jkh_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JkhUnitID instead. It exists only for internal usage by the builders.
func (m *InspectorUnitMutation) JkhUnitIDs() (ids []int) {
	if id := m.jkh_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJkhUnit resets all changes to the "jkh_unit" edge.
func (m *InspectorUnitMutation) ResetJkhUnit() {
	m.jkh_unit = nil
	m.clearedjkh_unit = false
}

// Where appends a list predicates to the InspectorUnitMutation builder.
func (m *InspectorUnitMutation) Where(ps ...predicate.InspectorUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InspectorUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InspectorUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InspectorUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InspectorUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InspectorUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InspectorUnit).
func (m *InspectorUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InspectorUnitMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.inspector != nil {
		fields = append(fields, inspectorunit.FieldUserID)
	}
	if m.jkh_unit != nil {
		fields = append(fields, inspectorunit.FieldJkhUnitID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InspectorUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inspectorunit.FieldUserID:
		return m.UserID()
	case inspectorunit.FieldJkhUnitID:
		return m.JkhUnitID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InspectorUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inspectorunit.FieldUserID:
		return m.OldUserID(ctx)
	case inspectorunit.FieldJkhUnitID:
		return m.OldJkhUnitID(ctx)
	}
	return nil, fmt.Errorf("unknown InspectorUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InspectorUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inspectorunit.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case inspectorunit.FieldJkhUnitID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJkhUnitID(v)
		return nil
	}
	return fmt.Errorf("unknown InspectorUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InspectorUnitMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InspectorUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InspectorUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InspectorUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InspectorUnitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InspectorUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InspectorUnitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InspectorUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InspectorUnitMutation) ResetField(name string) error {
	switch name {
	case inspectorunit.FieldUserID:
		m.ResetUserID()
		return nil
	case inspectorunit.FieldJkhUnitID:
		m.ResetJkhUnitID()
		return nil
	}
	return fmt.Errorf("unknown InspectorUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InspectorUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.inspector != nil {
		edges = append(edges, inspectorunit.EdgeInspector)
	}
	if m.jkh_unit != nil {
		edges = append(edges, inspectorunit.EdgeJkhUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InspectorUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inspectorunit.EdgeInspector:
		if id := m.inspector; id != nil {
			return []ent.Value{*id}
		}
	case inspectorunit.EdgeJkhUnit:
		if id := m.jkh_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InspectorUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InspectorUnitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InspectorUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinspector {
		edges = append(edges, inspectorunit.EdgeInspector)
	}
	if m.clearedjkh_unit {
		edges = append(edges, inspectorunit.EdgeJkhUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InspectorUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case inspectorunit.EdgeInspector:
		return m.clearedinspector
	case inspectorunit.EdgeJkhUnit:
		return m.clearedjkh_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InspectorUnitMutation) ClearEdge(name string) error {
	switch name {
	case inspectorunit.EdgeInspector:
		m.ClearInspector()
		return nil
	case inspectorunit.EdgeJkhUnit:
		m.ClearJkhUnit()
		return nil
	}
	return fmt.Errorf("unknown InspectorUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InspectorUnitMutation) ResetEdge(name string) error {
	switch name {
	case inspectorunit.EdgeInspector:
		m.ResetInspector()
		return nil
	case inspectorunit.EdgeJkhUnit:
		m.ResetJkhUnit()
		return nil
	}
	return fmt.Errorf("unknown InspectorUnit edge %s", name)
}

// JkhUnitMutation represents an operation that mutates the JkhUnit nodes in the graph.
type JkhUnitMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	name                       *string
	clearedFields              map[string]struct{}
	district                   *int
	cleareddistrict            bool
	buildings                  map[int]struct{}
	removedbuildings           map[int]struct{}
	clearedbuildings           bool
	assigned_inspectors        map[int]struct{}
	removedassigned_inspectors map[int]struct{}
	clearedassigned_inspectors bool
	done                       bool
	oldValue                   func(context.Context) (*JkhUnit, error)
	predicates                 []predicate.JkhUnit
}

var _ ent.Mutation = (*JkhUnitMutation)(nil)

// jkhunitOption allows management of the mutation configuration using functional options.
type jkhunitOption func(*JkhUnitMutation)

// newJkhUnitMutation creates new mutation for the JkhUnit entity.
func newJkhUnitMutation(c config, op Op, opts ...jkhunitOption) *JkhUnitMutation {
	m := &JkhUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeJkhUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJkhUnitID sets the ID field of the mutation.
func withJkhUnitID(id int) jkhunitOption {
	return func(m *JkhUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *JkhUnit
		)
		m.oldValue = func(ctx context.Context) (*JkhUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JkhUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJkhUnit sets the old JkhUnit of the mutation.
func withJkhUnit(node *JkhUnit) jkhunitOption {
	return func(m *JkhUnitMutation) {
		m.oldValue = func(context.Context) (*JkhUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JkhUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JkhUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JkhUnitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JkhUnitMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JkhUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDistrictID sets the "district_id" field.
func (m *JkhUnitMutation) SetDistrictID(i int) {
	m.district = &i
}

// DistrictID returns the value of the "district_id" field in the mutation.
func (m *JkhUnitMutation) DistrictID() (r int, exists bool) {
	v := m.district
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "district_id" field's value of the JkhUnit entity.
// If the JkhUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JkhUnitMutation) OldDistrictID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// ResetDistrictID resets all changes to the "district_id" field.
func (m *JkhUnitMutation) ResetDistrictID() {
	m.district = nil
}

// SetName sets the "name" field.
func (m *JkhUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *JkhUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the JkhUnit entity.
// If the JkhUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JkhUnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *JkhUnitMutation) ResetName() {
	m.name = nil
}

// ClearDistrict clears the "district" edge to the District entity.
func (m *JkhUnitMutation) ClearDistrict() {
	m.cleareddistrict = true
	m.clearedFields[jkhunit.FieldDistrictID] = struct{}{}
}

// DistrictCleared reports if the "district" edge to the District entity was cleared.
func (m *JkhUnitMutation) DistrictCleared() bool {
	return m.cleareddistrict
}

// DistrictIDs returns the "district" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DistrictID instead. It exists only for internal usage by the builders.
func (m *JkhUnitMutation) DistrictIDs() (ids []int) {
	if id := m.district; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDistrict resets all changes to the "district" edge.
func (m *JkhUnitMutation) ResetDistrict() {
	m.district = nil
	m.cleareddistrict = false
}

// AddBuildingIDs adds the "buildings" edge to the Building entity by ids.
func (m *JkhUnitMutation) AddBuildingIDs(ids ...int) {
	if m.buildings == nil {
		m.buildings = make(map[int]struct{})
	}
	for i := range ids {
		m.buildings[ids[i]] = struct{}{}
	}
}

// ClearBuildings clears the "buildings" edge to the Building entity.
func (m *JkhUnitMutation) ClearBuildings() {
	m.clearedbuildings = true
}

// BuildingsCleared reports if the "buildings" edge to the Building entity was cleared.
func (m *JkhUnitMutation) BuildingsCleared() bool {
	return m.clearedbuildings
}

// RemoveBuildingIDs removes the "buildings" edge to the Building entity by IDs.
func (m *JkhUnitMutation) RemoveBuildingIDs(ids ...int) {
	if m.removedbuildings == nil {
		m.removedbuildings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.buildings, ids[i])
		m.removedbuildings[ids[i]] = struct{}{}
	}
}

// RemovedBuildings returns the removed IDs of the "buildings" edge to the Building entity.
func (m *JkhUnitMutation) RemovedBuildingsIDs() (ids []int) {
	for id := range m.removedbuildings {
		ids = append(ids, id)
	}
	return
}

// BuildingsIDs returns the "buildings" edge IDs in the mutation.
func (m *JkhUnitMutation) BuildingsIDs() (ids []int) {
	for id := range m.buildings {
		ids = append(ids, id)
	}
	return
}

// ResetBuildings resets all changes to the "buildings" edge.
func (m *JkhUnitMutation) ResetBuildings() {
	m.buildings = nil
	m.clearedbuildings = false
	m.removedbuildings = nil
}

// AddAssignedInspectorIDs adds the "assigned_inspectors" edge to the InspectorUnit entity by ids.
func (m *JkhUnitMutation) AddAssignedInspectorIDs(ids ...int) {
	if m.assigned_inspectors == nil {
		m.assigned_inspectors = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_inspectors[ids[i]] = struct{}{}
	}
}

// ClearAssignedInspectors clears the "assigned_inspectors" edge to the InspectorUnit entity.
func (m *JkhUnitMutation) ClearAssignedInspectors() {
	m.clearedassigned_inspectors = true
}

// AssignedInspectorsCleared reports if the "assigned_inspectors" edge to the InspectorUnit entity was cleared.
func (m *JkhUnitMutation) AssignedInspectorsCleared() bool {
	return m.clearedassigned_inspectors
}

// RemoveAssignedInspectorIDs removes the "assigned_inspectors" edge to the InspectorUnit entity by IDs.
func (m *JkhUnitMutation) RemoveAssignedInspectorIDs(ids ...int) {
	if m.removedassigned_inspectors == nil {
		m.removedassigned_inspectors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_inspectors, ids[i])
		m.removedassigned_inspectors[ids[i]] = struct{}{}
	}
}

// RemovedAssignedInspectors returns the removed IDs of the "assigned_inspectors" edge to the InspectorUnit entity.
func (m *JkhUnitMutation) RemovedAssignedInspectorsIDs() (ids []int) {
	for id := range m.removedassigned_inspectors {
		ids = append(ids, id)
	}
	return
}

// AssignedInspectorsIDs returns the "assigned_inspectors" edge IDs in the mutation.
func (m *JkhUnitMutation) AssignedInspectorsIDs() (ids []int) {
	for id := range m.assigned_inspectors {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedInspectors resets all changes to the "assigned_inspectors" edge.
func (m *JkhUnitMutation) ResetAssignedInspectors() {
	m.assigned_inspectors = nil
	m.clearedassigned_inspectors = false
	m.removedassigned_inspectors = nil
}

// Where appends a list predicates to the JkhUnitMutation builder.
func (m *JkhUnitMutation) Where(ps ...predicate.JkhUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JkhUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JkhUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JkhUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JkhUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JkhUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JkhUnit).
func (m *JkhUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JkhUnitMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.district != nil {
		fields = append(fields, jkhunit.FieldDistrictID)
	}
	if m.name != nil {
		fields = append(fields, jkhunit.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JkhUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jkhunit.FieldDistrictID:
		return m.DistrictID()
	case jkhunit.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JkhUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jkhunit.FieldDistrictID:
		return m.OldDistrictID(ctx)
	case jkhunit.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown JkhUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JkhUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jkhunit.FieldDistrictID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	case jkhunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown JkhUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JkhUnitMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JkhUnitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JkhUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JkhUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JkhUnitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JkhUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JkhUnitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JkhUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JkhUnitMutation) ResetField(name string) error {
	switch name {
	case jkhunit.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	case jkhunit.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown JkhUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JkhUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.district != nil {
		edges = append(edges, jkhunit.EdgeDistrict)
	}
	if m.buildings != nil {
		edges = append(edges, jkhunit.EdgeBuildings)
	}
	if m.assigned_inspectors != nil {
		edges = append(edges, jkhunit.EdgeAssignedInspectors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JkhUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jkhunit.EdgeDistrict:
		if id := m.district; id != nil {
			return []ent.Value{*id}
		}
	case jkhunit.EdgeBuildings:
		ids := make([]ent.Value, 0, len(m.buildings))
		for id := range m.buildings {
			ids = append(ids, id)
		}
		return ids
	case jkhunit.EdgeAssignedInspectors:
		ids := make([]ent.Value, 0, len(m.assigned_inspectors))
		for id := range m.assigned_inspectors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JkhUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbuildings != nil {
		edges = append(edges, jkhunit.EdgeBuildings)
	}
	if m.removedassigned_inspectors != nil {
		edges = append(edges, jkhunit.EdgeAssignedInspectors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JkhUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jkhunit.EdgeBuildings:
		ids := make([]ent.Value, 0, len(m.removedbuildings))
		for id := range m.removedbuildings {
			ids = append(ids, id)
		}
		return ids
	case jkhunit.EdgeAssignedInspectors:
		ids := make([]ent.Value, 0, len(m.removedassigned_inspectors))
		for id := range m.removedassigned_inspectors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JkhUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddistrict {
		edges = append(edges, jkhunit.EdgeDistrict)
	}
	if m.clearedbuildings {
		edges = append(edges, jkhunit.EdgeBuildings)
	}
	if m.clearedassigned_inspectors {
		edges = append(edges, jkhunit.EdgeAssignedInspectors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JkhUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case jkhunit.EdgeDistrict:
		return m.cleareddistrict
	case jkhunit.EdgeBuildings:
		return m.clearedbuildings
	case jkhunit.EdgeAssignedInspectors:
		return m.clearedassigned_inspectors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JkhUnitMutation) ClearEdge(name string) error {
	switch name {
	case jkhunit.EdgeDistrict:
		m.ClearDistrict()
		return nil
	}
	return fmt.Errorf("unknown JkhUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JkhUnitMutation) ResetEdge(name string) error {
	switch name {
	case jkhunit.EdgeDistrict:
		m.ResetDistrict()
		return nil
	case jkhunit.EdgeBuildings:
		m.ResetBuildings()
		return nil
	case jkhunit.EdgeAssignedInspectors:
		m.ResetAssignedInspectors()
		return nil
	}
	return fmt.Errorf("unknown JkhUnit edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id int) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op               Op
	typ              string
	id               *int
	title            *string
	priority         *string
	status           *task.Status
	description      *string
	scheduled_date   *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	inspector        *int
	clearedinspector bool
	building         *int
	clearedbuilding  bool
	checklist        *int
	clearedchecklist bool
	results          map[int]struct{}
	removedresults   map[int]struct{}
	clearedresults   bool
	act              *int
	clearedact       bool
	done             bool
	oldValue         func(context.Context) (*Task, error)
	predicates       []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBuildingID sets the "building_id" field.
func (m *TaskMutation) SetBuildingID(i int) {
	m.building = &i
}

// BuildingID returns the value of the "building_id" field in the mutation.
func (m *TaskMutation) BuildingID() (r int, exists bool) {
	v := m.building
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildingID returns the old "building_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldBuildingID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildingID: %w", err)
	}
	return oldValue.BuildingID, nil
}

// ResetBuildingID resets all changes to the "building_id" field.
func (m *TaskMutation) ResetBuildingID() {
	m.building = nil
}

// SetChecklistID sets the "checklist_id" field.
func (m *TaskMutation) SetChecklistID(i int) {
	m.checklist = &i
}

// ChecklistID returns the value of the "checklist_id" field in the mutation.
func (m *TaskMutation) ChecklistID() (r int, exists bool) {
	v := m.checklist
	if v == nil {
		return
	}
	return *v, true
}

// OldChecklistID returns the old "checklist_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldChecklistID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecklistID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecklistID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecklistID: %w", err)
	}
	return oldValue.ChecklistID, nil
}

// ResetChecklistID resets all changes to the "checklist_id" field.
func (m *TaskMutation) ResetChecklistID() {
	m.checklist = nil
}

// SetInspectorID sets the "inspector_id" field.
func (m *TaskMutation) SetInspectorID(i int) {
	m.inspector = &i
}

// InspectorID returns the value of the "inspector_id" field in the mutation.
func (m *TaskMutation) InspectorID() (r int, exists bool) {
	v := m.inspector
	if v == nil {
		return
	}
	return *v, true
}

// OldInspectorID returns the old "inspector_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldInspectorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInspectorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInspectorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInspectorID: %w", err)
	}
	return oldValue.InspectorID, nil
}

// ResetInspectorID resets all changes to the "inspector_id" field.
func (m *TaskMutation) ResetInspectorID() {
	m.inspector = nil
}

// SetTitle sets the "title" field.
func (m *TaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskMutation) ResetTitle() {
	m.title = nil
}

// SetPriority sets the "priority" field.
func (m *TaskMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TaskMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TaskMutation) ResetPriority() {
	m.priority = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(t task.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r task.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v task.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[task.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[task.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, task.FieldDescription)
}

// SetScheduledDate sets the "scheduled_date" field.
func (m *TaskMutation) SetScheduledDate(t time.Time) {
	m.scheduled_date = &t
}

// ScheduledDate returns the value of the "scheduled_date" field in the mutation.
func (m *TaskMutation) ScheduledDate() (r time.Time, exists bool) {
	v := m.scheduled_date
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledDate returns the old "scheduled_date" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldScheduledDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledDate: %w", err)
	}
	return oldValue.ScheduledDate, nil
}

// ResetScheduledDate resets all changes to the "scheduled_date" field.
func (m *TaskMutation) ResetScheduledDate() {
	m.scheduled_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearInspector clears the "inspector" edge to the User entity.
func (m *TaskMutation) ClearInspector() {
	m.clearedinspector = true
	m.clearedFields[task.FieldInspectorID] = struct{}{}
}

// InspectorCleared reports if the "inspector" edge to the User entity was cleared.
func (m *TaskMutation) InspectorCleared() bool {
	return m.clearedinspector
}

// InspectorIDs returns the "inspector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InspectorID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) InspectorIDs() (ids []int) {
	if id := m.inspector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInspector resets all changes to the "inspector" edge.
func (m *TaskMutation) ResetInspector() {
	m.inspector = nil
	m.clearedinspector = false
}

// ClearBuilding clears the "building" edge to the Building entity.
func (m *TaskMutation) ClearBuilding() {
	m.clearedbuilding = true
	m.clearedFields[task.FieldBuildingID] = struct{}{}
}

// BuildingCleared reports if the "building" edge to the Building entity was cleared.
func (m *TaskMutation) BuildingCleared() bool {
	return m.clearedbuilding
}

// BuildingIDs returns the "building" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BuildingID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) BuildingIDs() (ids []int) {
	if id := m.building; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBuilding resets all changes to the "building" edge.
func (m *TaskMutation) ResetBuilding() {
	m.building = nil
	m.clearedbuilding = false
}

// ClearChecklist clears the "checklist" edge to the Checklist entity.
func (m *TaskMutation) ClearChecklist() {
	m.clearedchecklist = true
	m.clearedFields[task.FieldChecklistID] = struct{}{}
}

// ChecklistCleared reports if the "checklist" edge to the Checklist entity was cleared.
func (m *TaskMutation) ChecklistCleared() bool {
	return m.clearedchecklist
}

// ChecklistIDs returns the "checklist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChecklistID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ChecklistIDs() (ids []int) {
	if id := m.checklist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChecklist resets all changes to the "checklist" edge.
func (m *TaskMutation) ResetChecklist() {
	m.checklist = nil
	m.clearedchecklist = false
}

// AddResultIDs adds the "results" edge to the InspectionResult entity by ids.
func (m *TaskMutation) AddResultIDs(ids ...int) {
	if m.results == nil {
		m.results = make(map[int]struct{})
	}
	for i := range ids {
		m.results[ids[i]] = struct{}{}
	}
}

// ClearResults clears the "results" edge to the InspectionResult entity.
func (m *TaskMutation) ClearResults() {
	m.clearedresults = true
}

// ResultsCleared reports if the "results" edge to the InspectionResult entity was cleared.
func (m *TaskMutation) ResultsCleared() bool {
	return m.clearedresults
}

// RemoveResultIDs removes the "results" edge to the InspectionResult entity by IDs.
func (m *TaskMutation) RemoveResultIDs(ids ...int) {
	if m.removedresults == nil {
		m.removedresults = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.results, ids[i])
		m.removedresults[ids[i]] = struct{}{}
	}
}

// RemovedResults returns the removed IDs of the "results" edge to the InspectionResult entity.
func (m *TaskMutation) RemovedResultsIDs() (ids []int) {
	for id := range m.removedresults {
		ids = append(ids, id)
	}
	return
}

// ResultsIDs returns the "results" edge IDs in the mutation.
func (m *TaskMutation) ResultsIDs() (ids []int) {
	for id := range m.results {
		ids = append(ids, id)
	}
	return
}

// ResetResults resets all changes to the "results" edge.
func (m *TaskMutation) ResetResults() {
	m.results = nil
	m.clearedresults = false
	m.removedresults = nil
}

// SetActID sets the "act" edge to the InspectionAct entity by id.
func (m *TaskMutation) SetActID(id int) {
	m.act = &id
}

// ClearAct clears the "act" edge to the InspectionAct entity.
func (m *TaskMutation) ClearAct() {
	m.clearedact = true
}

// ActCleared reports if the "act" edge to the InspectionAct entity was cleared.
func (m *TaskMutation) ActCleared() bool {
	return m.clearedact
}

// ActID returns the "act" edge ID in the mutation.
func (m *TaskMutation) ActID() (id int, exists bool) {
	if m.act != nil {
		return *m.act, true
	}
	return
}

// ActIDs returns the "act" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ActIDs() (ids []int) {
	if id := m.act; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAct resets all changes to the "act" edge.
func (m *TaskMutation) ResetAct() {
	m.act = nil
	m.clearedact = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.building != nil {
		fields = append(fields, task.FieldBuildingID)
	}
	if m.checklist != nil {
		fields = append(fields, task.FieldChecklistID)
	}
	if m.inspector != nil {
		fields = append(fields, task.FieldInspectorID)
	}
	if m.title != nil {
		fields = append(fields, task.FieldTitle)
	}
	if m.priority != nil {
		fields = append(fields, task.FieldPriority)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, task.FieldDescription)
	}
	if m.scheduled_date != nil {
		fields = append(fields, task.FieldScheduledDate)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldBuildingID:
		return m.BuildingID()
	case task.FieldChecklistID:
		return m.ChecklistID()
	case task.FieldInspectorID:
		return m.InspectorID()
	case task.FieldTitle:
		return m.Title()
	case task.FieldPriority:
		return m.Priority()
	case task.FieldStatus:
		return m.Status()
	case task.FieldDescription:
		return m.Description()
	case task.FieldScheduledDate:
		return m.ScheduledDate()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldBuildingID:
		return m.OldBuildingID(ctx)
	case task.FieldChecklistID:
		return m.OldChecklistID(ctx)
	case task.FieldInspectorID:
		return m.OldInspectorID(ctx)
	case task.FieldTitle:
		return m.OldTitle(ctx)
	case task.FieldPriority:
		return m.OldPriority(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldDescription:
		return m.OldDescription(ctx)
	case task.FieldScheduledDate:
		return m.OldScheduledDate(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldBuildingID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildingID(v)
		return nil
	case task.FieldChecklistID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecklistID(v)
		return nil
	case task.FieldInspectorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInspectorID(v)
		return nil
	case task.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case task.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(task.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case task.FieldScheduledDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledDate(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldDescription) {
		fields = append(fields, task.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldBuildingID:
		m.ResetBuildingID()
		return nil
	case task.FieldChecklistID:
		m.ResetChecklistID()
		return nil
	case task.FieldInspectorID:
		m.ResetInspectorID()
		return nil
	case task.FieldTitle:
		m.ResetTitle()
		return nil
	case task.FieldPriority:
		m.ResetPriority()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldDescription:
		m.ResetDescription()
		return nil
	case task.FieldScheduledDate:
		m.ResetScheduledDate()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.inspector != nil {
		edges = append(edges, task.EdgeInspector)
	}
	if m.building != nil {
		edges = append(edges, task.EdgeBuilding)
	}
	if m.checklist != nil {
		edges = append(edges, task.EdgeChecklist)
	}
	if m.results != nil {
		edges = append(edges, task.EdgeResults)
	}
	if m.act != nil {
		edges = append(edges, task.EdgeAct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeInspector:
		if id := m.inspector; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeBuilding:
		if id := m.building; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeChecklist:
		if id := m.checklist; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeResults:
		ids := make([]ent.Value, 0, len(m.results))
		for id := range m.results {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeAct:
		if id := m.act; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedresults != nil {
		edges = append(edges, task.EdgeResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeResults:
		ids := make([]ent.Value, 0, len(m.removedresults))
		for id := range m.removedresults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedinspector {
		edges = append(edges, task.EdgeInspector)
	}
	if m.clearedbuilding {
		edges = append(edges, task.EdgeBuilding)
	}
	if m.clearedchecklist {
		edges = append(edges, task.EdgeChecklist)
	}
	if m.clearedresults {
		edges = append(edges, task.EdgeResults)
	}
	if m.clearedact {
		edges = append(edges, task.EdgeAct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeInspector:
		return m.clearedinspector
	case task.EdgeBuilding:
		return m.clearedbuilding
	case task.EdgeChecklist:
		return m.clearedchecklist
	case task.EdgeResults:
		return m.clearedresults
	case task.EdgeAct:
		return m.clearedact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeInspector:
		m.ClearInspector()
		return nil
	case task.EdgeBuilding:
		m.ClearBuilding()
		return nil
	case task.EdgeChecklist:
		m.ClearChecklist()
		return nil
	case task.EdgeAct:
		m.ClearAct()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeInspector:
		m.ResetInspector()
		return nil
	case task.EdgeBuilding:
		m.ResetBuilding()
		return nil
	case task.EdgeChecklist:
		m.ResetChecklist()
		return nil
	case task.EdgeResults:
		m.ResetResults()
		return nil
	case task.EdgeAct:
		m.ResetAct()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	email                     *string
	login                     *string
	password_hash             *string
	first_name                *string
	last_name                 *string
	clearedFields             map[string]struct{}
	role                      *int
	clearedrole               bool
	inspections               map[int]struct{}
	removedinspections        map[int]struct{}
	clearedinspections        bool
	assigned_buildings        map[int]struct{}
	removedassigned_buildings map[int]struct{}
	clearedassigned_buildings bool
	assigned_units            map[int]struct{}
	removedassigned_units     map[int]struct{}
	clearedassigned_units     bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(i int) {
	m.role = &i
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetLogin sets the "login" field.
func (m *UserMutation) SetLogin(s string) {
	m.login = &s
}

// Login returns the value of the "login" field in the mutation.
func (m *UserMutation) Login() (r string, exists bool) {
	v := m.login
	if v == nil {
		return
	}
	return *v, true
}

// OldLogin returns the old "login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLogin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogin: %w", err)
	}
	return oldValue.Login, nil
}

// ResetLogin resets all changes to the "login" field.
func (m *UserMutation) ResetLogin() {
	m.login = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// ClearRole clears the "role" edge to the Role entity.
func (m *UserMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *UserMutation) RoleCleared() bool {
	return m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RoleIDs() (ids []int) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *UserMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// AddInspectionIDs adds the "inspections" edge to the Task entity by ids.
func (m *UserMutation) AddInspectionIDs(ids ...int) {
	if m.inspections == nil {
		m.inspections = make(map[int]struct{})
	}
	for i := range ids {
		m.inspections[ids[i]] = struct{}{}
	}
}

// ClearInspections clears the "inspections" edge to the Task entity.
func (m *UserMutation) ClearInspections() {
	m.clearedinspections = true
}

// InspectionsCleared reports if the "inspections" edge to the Task entity was cleared.
func (m *UserMutation) InspectionsCleared() bool {
	return m.clearedinspections
}

// RemoveInspectionIDs removes the "inspections" edge to the Task entity by IDs.
func (m *UserMutation) RemoveInspectionIDs(ids ...int) {
	if m.removedinspections == nil {
		m.removedinspections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inspections, ids[i])
		m.removedinspections[ids[i]] = struct{}{}
	}
}

// RemovedInspections returns the removed IDs of the "inspections" edge to the Task entity.
func (m *UserMutation) RemovedInspectionsIDs() (ids []int) {
	for id := range m.removedinspections {
		ids = append(ids, id)
	}
	return
}

// InspectionsIDs returns the "inspections" edge IDs in the mutation.
func (m *UserMutation) InspectionsIDs() (ids []int) {
	for id := range m.inspections {
		ids = append(ids, id)
	}
	return
}

// ResetInspections resets all changes to the "inspections" edge.
func (m *UserMutation) ResetInspections() {
	m.inspections = nil
	m.clearedinspections = false
	m.removedinspections = nil
}

// AddAssignedBuildingIDs adds the "assigned_buildings" edge to the Building entity by ids.
func (m *UserMutation) AddAssignedBuildingIDs(ids ...int) {
	if m.assigned_buildings == nil {
		m.assigned_buildings = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_buildings[ids[i]] = struct{}{}
	}
}

// ClearAssignedBuildings clears the "assigned_buildings" edge to the Building entity.
func (m *UserMutation) ClearAssignedBuildings() {
	m.clearedassigned_buildings = true
}

// AssignedBuildingsCleared reports if the "assigned_buildings" edge to the Building entity was cleared.
func (m *UserMutation) AssignedBuildingsCleared() bool {
	return m.clearedassigned_buildings
}

// RemoveAssignedBuildingIDs removes the "assigned_buildings" edge to the Building entity by IDs.
func (m *UserMutation) RemoveAssignedBuildingIDs(ids ...int) {
	if m.removedassigned_buildings == nil {
		m.removedassigned_buildings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_buildings, ids[i])
		m.removedassigned_buildings[ids[i]] = struct{}{}
	}
}

// RemovedAssignedBuildings returns the removed IDs of the "assigned_buildings" edge to the Building entity.
func (m *UserMutation) RemovedAssignedBuildingsIDs() (ids []int) {
	for id := range m.removedassigned_buildings {
		ids = append(ids, id)
	}
	return
}

// AssignedBuildingsIDs returns the "assigned_buildings" edge IDs in the mutation.
func (m *UserMutation) AssignedBuildingsIDs() (ids []int) {
	for id := range m.assigned_buildings {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedBuildings resets all changes to the "assigned_buildings" edge.
func (m *UserMutation) ResetAssignedBuildings() {
	m.assigned_buildings = nil
	m.clearedassigned_buildings = false
	m.removedassigned_buildings = nil
}

// AddAssignedUnitIDs adds the "assigned_units" edge to the InspectorUnit entity by ids.
func (m *UserMutation) AddAssignedUnitIDs(ids ...int) {
	if m.assigned_units == nil {
		m.assigned_units = make(map[int]struct{})
	}
	for i := range ids {
		m.assigned_units[ids[i]] = struct{}{}
	}
}

// ClearAssignedUnits clears the "assigned_units" edge to the InspectorUnit entity.
func (m *UserMutation) ClearAssignedUnits() {
	m.clearedassigned_units = true
}

// AssignedUnitsCleared reports if the "assigned_units" edge to the InspectorUnit entity was cleared.
func (m *UserMutation) AssignedUnitsCleared() bool {
	return m.clearedassigned_units
}

// RemoveAssignedUnitIDs removes the "assigned_units" edge to the InspectorUnit entity by IDs.
func (m *UserMutation) RemoveAssignedUnitIDs(ids ...int) {
	if m.removedassigned_units == nil {
		m.removedassigned_units = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assigned_units, ids[i])
		m.removedassigned_units[ids[i]] = struct{}{}
	}
}

// RemovedAssignedUnits returns the removed IDs of the "assigned_units" edge to the InspectorUnit entity.
func (m *UserMutation) RemovedAssignedUnitsIDs() (ids []int) {
	for id := range m.removedassigned_units {
		ids = append(ids, id)
	}
	return
}

// AssignedUnitsIDs returns the "assigned_units" edge IDs in the mutation.
func (m *UserMutation) AssignedUnitsIDs() (ids []int) {
	for id := range m.assigned_units {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedUnits resets all changes to the "assigned_units" edge.
func (m *UserMutation) ResetAssignedUnits() {
	m.assigned_units = nil
	m.clearedassigned_units = false
	m.removedassigned_units = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.role != nil {
		fields = append(fields, user.FieldRoleID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.login != nil {
		fields = append(fields, user.FieldLogin)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRoleID:
		return m.RoleID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldLogin:
		return m.Login()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldLogin:
		return m.OldLogin(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldRoleID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogin(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldLogin:
		m.ResetLogin()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.role != nil {
		edges = append(edges, user.EdgeRole)
	}
	if m.inspections != nil {
		edges = append(edges, user.EdgeInspections)
	}
	if m.assigned_buildings != nil {
		edges = append(edges, user.EdgeAssignedBuildings)
	}
	if m.assigned_units != nil {
		edges = append(edges, user.EdgeAssignedUnits)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeInspections:
		ids := make([]ent.Value, 0, len(m.inspections))
		for id := range m.inspections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedBuildings:
		ids := make([]ent.Value, 0, len(m.assigned_buildings))
		for id := range m.assigned_buildings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedUnits:
		ids := make([]ent.Value, 0, len(m.assigned_units))
		for id := range m.assigned_units {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedinspections != nil {
		edges = append(edges, user.EdgeInspections)
	}
	if m.removedassigned_buildings != nil {
		edges = append(edges, user.EdgeAssignedBuildings)
	}
	if m.removedassigned_units != nil {
		edges = append(edges, user.EdgeAssignedUnits)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeInspections:
		ids := make([]ent.Value, 0, len(m.removedinspections))
		for id := range m.removedinspections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedBuildings:
		ids := make([]ent.Value, 0, len(m.removedassigned_buildings))
		for id := range m.removedassigned_buildings {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedUnits:
		ids := make([]ent.Value, 0, len(m.removedassigned_units))
		for id := range m.removedassigned_units {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedrole {
		edges = append(edges, user.EdgeRole)
	}
	if m.clearedinspections {
		edges = append(edges, user.EdgeInspections)
	}
	if m.clearedassigned_buildings {
		edges = append(edges, user.EdgeAssignedBuildings)
	}
	if m.clearedassigned_units {
		edges = append(edges, user.EdgeAssignedUnits)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRole:
		return m.clearedrole
	case user.EdgeInspections:
		return m.clearedinspections
	case user.EdgeAssignedBuildings:
		return m.clearedassigned_buildings
	case user.EdgeAssignedUnits:
		return m.clearedassigned_units
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRole:
		m.ResetRole()
		return nil
	case user.EdgeInspections:
		m.ResetInspections()
		return nil
	case user.EdgeAssignedBuildings:
		m.ResetAssignedBuildings()
		return nil
	case user.EdgeAssignedUnits:
		m.ResetAssignedUnits()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
