// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"jkh/ent/migrate"

	"jkh/ent/building"
	"jkh/ent/checklist"
	"jkh/ent/checklistelement"
	"jkh/ent/district"
	"jkh/ent/elementcatalog"
	"jkh/ent/inspectionact"
	"jkh/ent/inspectionresult"
	"jkh/ent/inspectorunit"
	"jkh/ent/jkhunit"
	"jkh/ent/role"
	"jkh/ent/task"
	"jkh/ent/user"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Building is the client for interacting with the Building builders.
	Building *BuildingClient
	// Checklist is the client for interacting with the Checklist builders.
	Checklist *ChecklistClient
	// ChecklistElement is the client for interacting with the ChecklistElement builders.
	ChecklistElement *ChecklistElementClient
	// District is the client for interacting with the District builders.
	District *DistrictClient
	// ElementCatalog is the client for interacting with the ElementCatalog builders.
	ElementCatalog *ElementCatalogClient
	// InspectionAct is the client for interacting with the InspectionAct builders.
	InspectionAct *InspectionActClient
	// InspectionResult is the client for interacting with the InspectionResult builders.
	InspectionResult *InspectionResultClient
	// InspectorUnit is the client for interacting with the InspectorUnit builders.
	InspectorUnit *InspectorUnitClient
	// JkhUnit is the client for interacting with the JkhUnit builders.
	JkhUnit *JkhUnitClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Task is the client for interacting with the Task builders.
	Task *TaskClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Building = NewBuildingClient(c.config)
	c.Checklist = NewChecklistClient(c.config)
	c.ChecklistElement = NewChecklistElementClient(c.config)
	c.District = NewDistrictClient(c.config)
	c.ElementCatalog = NewElementCatalogClient(c.config)
	c.InspectionAct = NewInspectionActClient(c.config)
	c.InspectionResult = NewInspectionResultClient(c.config)
	c.InspectorUnit = NewInspectorUnitClient(c.config)
	c.JkhUnit = NewJkhUnitClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Task = NewTaskClient(c.config)
	c.User = NewUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Building:         NewBuildingClient(cfg),
		Checklist:        NewChecklistClient(cfg),
		ChecklistElement: NewChecklistElementClient(cfg),
		District:         NewDistrictClient(cfg),
		ElementCatalog:   NewElementCatalogClient(cfg),
		InspectionAct:    NewInspectionActClient(cfg),
		InspectionResult: NewInspectionResultClient(cfg),
		InspectorUnit:    NewInspectorUnitClient(cfg),
		JkhUnit:          NewJkhUnitClient(cfg),
		Role:             NewRoleClient(cfg),
		Task:             NewTaskClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		Building:         NewBuildingClient(cfg),
		Checklist:        NewChecklistClient(cfg),
		ChecklistElement: NewChecklistElementClient(cfg),
		District:         NewDistrictClient(cfg),
		ElementCatalog:   NewElementCatalogClient(cfg),
		InspectionAct:    NewInspectionActClient(cfg),
		InspectionResult: NewInspectionResultClient(cfg),
		InspectorUnit:    NewInspectorUnitClient(cfg),
		JkhUnit:          NewJkhUnitClient(cfg),
		Role:             NewRoleClient(cfg),
		Task:             NewTaskClient(cfg),
		User:             NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Building.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Building, c.Checklist, c.ChecklistElement, c.District, c.ElementCatalog,
		c.InspectionAct, c.InspectionResult, c.InspectorUnit, c.JkhUnit, c.Role,
		c.Task, c.User,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Building, c.Checklist, c.ChecklistElement, c.District, c.ElementCatalog,
		c.InspectionAct, c.InspectionResult, c.InspectorUnit, c.JkhUnit, c.Role,
		c.Task, c.User,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BuildingMutation:
		return c.Building.mutate(ctx, m)
	case *ChecklistMutation:
		return c.Checklist.mutate(ctx, m)
	case *ChecklistElementMutation:
		return c.ChecklistElement.mutate(ctx, m)
	case *DistrictMutation:
		return c.District.mutate(ctx, m)
	case *ElementCatalogMutation:
		return c.ElementCatalog.mutate(ctx, m)
	case *InspectionActMutation:
		return c.InspectionAct.mutate(ctx, m)
	case *InspectionResultMutation:
		return c.InspectionResult.mutate(ctx, m)
	case *InspectorUnitMutation:
		return c.InspectorUnit.mutate(ctx, m)
	case *JkhUnitMutation:
		return c.JkhUnit.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *TaskMutation:
		return c.Task.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BuildingClient is a client for the Building schema.
type BuildingClient struct {
	config
}

// NewBuildingClient returns a client for the Building from the given config.
func NewBuildingClient(c config) *BuildingClient {
	return &BuildingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `building.Hooks(f(g(h())))`.
func (c *BuildingClient) Use(hooks ...Hook) {
	c.hooks.Building = append(c.hooks.Building, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `building.Intercept(f(g(h())))`.
func (c *BuildingClient) Intercept(interceptors ...Interceptor) {
	c.inters.Building = append(c.inters.Building, interceptors...)
}

// Create returns a builder for creating a Building entity.
func (c *BuildingClient) Create() *BuildingCreate {
	mutation := newBuildingMutation(c.config, OpCreate)
	return &BuildingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Building entities.
func (c *BuildingClient) CreateBulk(builders ...*BuildingCreate) *BuildingCreateBulk {
	return &BuildingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BuildingClient) MapCreateBulk(slice any, setFunc func(*BuildingCreate, int)) *BuildingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BuildingCreateBulk{err: fmt.Errorf("calling to BuildingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BuildingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BuildingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Building.
func (c *BuildingClient) Update() *BuildingUpdate {
	mutation := newBuildingMutation(c.config, OpUpdate)
	return &BuildingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BuildingClient) UpdateOne(_m *Building) *BuildingUpdateOne {
	mutation := newBuildingMutation(c.config, OpUpdateOne, withBuilding(_m))
	return &BuildingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BuildingClient) UpdateOneID(id int) *BuildingUpdateOne {
	mutation := newBuildingMutation(c.config, OpUpdateOne, withBuildingID(id))
	return &BuildingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Building.
func (c *BuildingClient) Delete() *BuildingDelete {
	mutation := newBuildingMutation(c.config, OpDelete)
	return &BuildingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BuildingClient) DeleteOne(_m *Building) *BuildingDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BuildingClient) DeleteOneID(id int) *BuildingDeleteOne {
	builder := c.Delete().Where(building.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BuildingDeleteOne{builder}
}

// Query returns a query builder for Building.
func (c *BuildingClient) Query() *BuildingQuery {
	return &BuildingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBuilding},
		inters: c.Interceptors(),
	}
}

// Get returns a Building entity by its id.
func (c *BuildingClient) Get(ctx context.Context, id int) (*Building, error) {
	return c.Query().Where(building.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BuildingClient) GetX(ctx context.Context, id int) *Building {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryJkhUnit queries the jkh_unit edge of a Building.
func (c *BuildingClient) QueryJkhUnit(_m *Building) *JkhUnitQuery {
	query := (&JkhUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(building.Table, building.FieldID, id),
			sqlgraph.To(jkhunit.Table, jkhunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, building.JkhUnitTable, building.JkhUnitColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDistrict queries the district edge of a Building.
func (c *BuildingClient) QueryDistrict(_m *Building) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(building.Table, building.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, building.DistrictTable, building.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInspector queries the inspector edge of a Building.
func (c *BuildingClient) QueryInspector(_m *Building) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(building.Table, building.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, building.InspectorTable, building.InspectorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Building.
func (c *BuildingClient) QueryTasks(_m *Building) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(building.Table, building.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, building.TasksTable, building.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BuildingClient) Hooks() []Hook {
	return c.hooks.Building
}

// Interceptors returns the client interceptors.
func (c *BuildingClient) Interceptors() []Interceptor {
	return c.inters.Building
}

func (c *BuildingClient) mutate(ctx context.Context, m *BuildingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BuildingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BuildingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BuildingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BuildingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Building mutation op: %q", m.Op())
	}
}

// ChecklistClient is a client for the Checklist schema.
type ChecklistClient struct {
	config
}

// NewChecklistClient returns a client for the Checklist from the given config.
func NewChecklistClient(c config) *ChecklistClient {
	return &ChecklistClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `checklist.Hooks(f(g(h())))`.
func (c *ChecklistClient) Use(hooks ...Hook) {
	c.hooks.Checklist = append(c.hooks.Checklist, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `checklist.Intercept(f(g(h())))`.
func (c *ChecklistClient) Intercept(interceptors ...Interceptor) {
	c.inters.Checklist = append(c.inters.Checklist, interceptors...)
}

// Create returns a builder for creating a Checklist entity.
func (c *ChecklistClient) Create() *ChecklistCreate {
	mutation := newChecklistMutation(c.config, OpCreate)
	return &ChecklistCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Checklist entities.
func (c *ChecklistClient) CreateBulk(builders ...*ChecklistCreate) *ChecklistCreateBulk {
	return &ChecklistCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChecklistClient) MapCreateBulk(slice any, setFunc func(*ChecklistCreate, int)) *ChecklistCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChecklistCreateBulk{err: fmt.Errorf("calling to ChecklistClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChecklistCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChecklistCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Checklist.
func (c *ChecklistClient) Update() *ChecklistUpdate {
	mutation := newChecklistMutation(c.config, OpUpdate)
	return &ChecklistUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChecklistClient) UpdateOne(_m *Checklist) *ChecklistUpdateOne {
	mutation := newChecklistMutation(c.config, OpUpdateOne, withChecklist(_m))
	return &ChecklistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChecklistClient) UpdateOneID(id int) *ChecklistUpdateOne {
	mutation := newChecklistMutation(c.config, OpUpdateOne, withChecklistID(id))
	return &ChecklistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Checklist.
func (c *ChecklistClient) Delete() *ChecklistDelete {
	mutation := newChecklistMutation(c.config, OpDelete)
	return &ChecklistDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChecklistClient) DeleteOne(_m *Checklist) *ChecklistDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChecklistClient) DeleteOneID(id int) *ChecklistDeleteOne {
	builder := c.Delete().Where(checklist.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChecklistDeleteOne{builder}
}

// Query returns a query builder for Checklist.
func (c *ChecklistClient) Query() *ChecklistQuery {
	return &ChecklistQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChecklist},
		inters: c.Interceptors(),
	}
}

// Get returns a Checklist entity by its id.
func (c *ChecklistClient) Get(ctx context.Context, id int) (*Checklist, error) {
	return c.Query().Where(checklist.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChecklistClient) GetX(ctx context.Context, id int) *Checklist {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryElements queries the elements edge of a Checklist.
func (c *ChecklistClient) QueryElements(_m *Checklist) *ChecklistElementQuery {
	query := (&ChecklistElementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checklist.Table, checklist.FieldID, id),
			sqlgraph.To(checklistelement.Table, checklistelement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, checklist.ElementsTable, checklist.ElementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTasks queries the tasks edge of a Checklist.
func (c *ChecklistClient) QueryTasks(_m *Checklist) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checklist.Table, checklist.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, checklist.TasksTable, checklist.TasksColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChecklistClient) Hooks() []Hook {
	return c.hooks.Checklist
}

// Interceptors returns the client interceptors.
func (c *ChecklistClient) Interceptors() []Interceptor {
	return c.inters.Checklist
}

func (c *ChecklistClient) mutate(ctx context.Context, m *ChecklistMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChecklistCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChecklistUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChecklistUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChecklistDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Checklist mutation op: %q", m.Op())
	}
}

// ChecklistElementClient is a client for the ChecklistElement schema.
type ChecklistElementClient struct {
	config
}

// NewChecklistElementClient returns a client for the ChecklistElement from the given config.
func NewChecklistElementClient(c config) *ChecklistElementClient {
	return &ChecklistElementClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `checklistelement.Hooks(f(g(h())))`.
func (c *ChecklistElementClient) Use(hooks ...Hook) {
	c.hooks.ChecklistElement = append(c.hooks.ChecklistElement, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `checklistelement.Intercept(f(g(h())))`.
func (c *ChecklistElementClient) Intercept(interceptors ...Interceptor) {
	c.inters.ChecklistElement = append(c.inters.ChecklistElement, interceptors...)
}

// Create returns a builder for creating a ChecklistElement entity.
func (c *ChecklistElementClient) Create() *ChecklistElementCreate {
	mutation := newChecklistElementMutation(c.config, OpCreate)
	return &ChecklistElementCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ChecklistElement entities.
func (c *ChecklistElementClient) CreateBulk(builders ...*ChecklistElementCreate) *ChecklistElementCreateBulk {
	return &ChecklistElementCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChecklistElementClient) MapCreateBulk(slice any, setFunc func(*ChecklistElementCreate, int)) *ChecklistElementCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChecklistElementCreateBulk{err: fmt.Errorf("calling to ChecklistElementClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChecklistElementCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChecklistElementCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ChecklistElement.
func (c *ChecklistElementClient) Update() *ChecklistElementUpdate {
	mutation := newChecklistElementMutation(c.config, OpUpdate)
	return &ChecklistElementUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChecklistElementClient) UpdateOne(_m *ChecklistElement) *ChecklistElementUpdateOne {
	mutation := newChecklistElementMutation(c.config, OpUpdateOne, withChecklistElement(_m))
	return &ChecklistElementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChecklistElementClient) UpdateOneID(id int) *ChecklistElementUpdateOne {
	mutation := newChecklistElementMutation(c.config, OpUpdateOne, withChecklistElementID(id))
	return &ChecklistElementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ChecklistElement.
func (c *ChecklistElementClient) Delete() *ChecklistElementDelete {
	mutation := newChecklistElementMutation(c.config, OpDelete)
	return &ChecklistElementDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChecklistElementClient) DeleteOne(_m *ChecklistElement) *ChecklistElementDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChecklistElementClient) DeleteOneID(id int) *ChecklistElementDeleteOne {
	builder := c.Delete().Where(checklistelement.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChecklistElementDeleteOne{builder}
}

// Query returns a query builder for ChecklistElement.
func (c *ChecklistElementClient) Query() *ChecklistElementQuery {
	return &ChecklistElementQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChecklistElement},
		inters: c.Interceptors(),
	}
}

// Get returns a ChecklistElement entity by its id.
func (c *ChecklistElementClient) Get(ctx context.Context, id int) (*ChecklistElement, error) {
	return c.Query().Where(checklistelement.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChecklistElementClient) GetX(ctx context.Context, id int) *ChecklistElement {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChecklist queries the checklist edge of a ChecklistElement.
func (c *ChecklistElementClient) QueryChecklist(_m *ChecklistElement) *ChecklistQuery {
	query := (&ChecklistClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checklistelement.Table, checklistelement.FieldID, id),
			sqlgraph.To(checklist.Table, checklist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, checklistelement.ChecklistTable, checklistelement.ChecklistColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryElementCatalog queries the element_catalog edge of a ChecklistElement.
func (c *ChecklistElementClient) QueryElementCatalog(_m *ChecklistElement) *ElementCatalogQuery {
	query := (&ElementCatalogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checklistelement.Table, checklistelement.FieldID, id),
			sqlgraph.To(elementcatalog.Table, elementcatalog.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, checklistelement.ElementCatalogTable, checklistelement.ElementCatalogColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInspectionResults queries the inspection_results edge of a ChecklistElement.
func (c *ChecklistElementClient) QueryInspectionResults(_m *ChecklistElement) *InspectionResultQuery {
	query := (&InspectionResultClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(checklistelement.Table, checklistelement.FieldID, id),
			sqlgraph.To(inspectionresult.Table, inspectionresult.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, checklistelement.InspectionResultsTable, checklistelement.InspectionResultsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChecklistElementClient) Hooks() []Hook {
	return c.hooks.ChecklistElement
}

// Interceptors returns the client interceptors.
func (c *ChecklistElementClient) Interceptors() []Interceptor {
	return c.inters.ChecklistElement
}

func (c *ChecklistElementClient) mutate(ctx context.Context, m *ChecklistElementMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChecklistElementCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChecklistElementUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChecklistElementUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChecklistElementDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ChecklistElement mutation op: %q", m.Op())
	}
}

// DistrictClient is a client for the District schema.
type DistrictClient struct {
	config
}

// NewDistrictClient returns a client for the District from the given config.
func NewDistrictClient(c config) *DistrictClient {
	return &DistrictClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `district.Hooks(f(g(h())))`.
func (c *DistrictClient) Use(hooks ...Hook) {
	c.hooks.District = append(c.hooks.District, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `district.Intercept(f(g(h())))`.
func (c *DistrictClient) Intercept(interceptors ...Interceptor) {
	c.inters.District = append(c.inters.District, interceptors...)
}

// Create returns a builder for creating a District entity.
func (c *DistrictClient) Create() *DistrictCreate {
	mutation := newDistrictMutation(c.config, OpCreate)
	return &DistrictCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of District entities.
func (c *DistrictClient) CreateBulk(builders ...*DistrictCreate) *DistrictCreateBulk {
	return &DistrictCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DistrictClient) MapCreateBulk(slice any, setFunc func(*DistrictCreate, int)) *DistrictCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DistrictCreateBulk{err: fmt.Errorf("calling to DistrictClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DistrictCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DistrictCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for District.
func (c *DistrictClient) Update() *DistrictUpdate {
	mutation := newDistrictMutation(c.config, OpUpdate)
	return &DistrictUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DistrictClient) UpdateOne(_m *District) *DistrictUpdateOne {
	mutation := newDistrictMutation(c.config, OpUpdateOne, withDistrict(_m))
	return &DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DistrictClient) UpdateOneID(id int) *DistrictUpdateOne {
	mutation := newDistrictMutation(c.config, OpUpdateOne, withDistrictID(id))
	return &DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for District.
func (c *DistrictClient) Delete() *DistrictDelete {
	mutation := newDistrictMutation(c.config, OpDelete)
	return &DistrictDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DistrictClient) DeleteOne(_m *District) *DistrictDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DistrictClient) DeleteOneID(id int) *DistrictDeleteOne {
	builder := c.Delete().Where(district.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DistrictDeleteOne{builder}
}

// Query returns a query builder for District.
func (c *DistrictClient) Query() *DistrictQuery {
	return &DistrictQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDistrict},
		inters: c.Interceptors(),
	}
}

// Get returns a District entity by its id.
func (c *DistrictClient) Get(ctx context.Context, id int) (*District, error) {
	return c.Query().Where(district.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DistrictClient) GetX(ctx context.Context, id int) *District {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryJkhUnits queries the jkh_units edge of a District.
func (c *DistrictClient) QueryJkhUnits(_m *District) *JkhUnitQuery {
	query := (&JkhUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(jkhunit.Table, jkhunit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, district.JkhUnitsTable, district.JkhUnitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildings queries the buildings edge of a District.
func (c *DistrictClient) QueryBuildings(_m *District) *BuildingQuery {
	query := (&BuildingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(district.Table, district.FieldID, id),
			sqlgraph.To(building.Table, building.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, district.BuildingsTable, district.BuildingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DistrictClient) Hooks() []Hook {
	return c.hooks.District
}

// Interceptors returns the client interceptors.
func (c *DistrictClient) Interceptors() []Interceptor {
	return c.inters.District
}

func (c *DistrictClient) mutate(ctx context.Context, m *DistrictMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DistrictCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DistrictUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DistrictUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DistrictDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown District mutation op: %q", m.Op())
	}
}

// ElementCatalogClient is a client for the ElementCatalog schema.
type ElementCatalogClient struct {
	config
}

// NewElementCatalogClient returns a client for the ElementCatalog from the given config.
func NewElementCatalogClient(c config) *ElementCatalogClient {
	return &ElementCatalogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `elementcatalog.Hooks(f(g(h())))`.
func (c *ElementCatalogClient) Use(hooks ...Hook) {
	c.hooks.ElementCatalog = append(c.hooks.ElementCatalog, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `elementcatalog.Intercept(f(g(h())))`.
func (c *ElementCatalogClient) Intercept(interceptors ...Interceptor) {
	c.inters.ElementCatalog = append(c.inters.ElementCatalog, interceptors...)
}

// Create returns a builder for creating a ElementCatalog entity.
func (c *ElementCatalogClient) Create() *ElementCatalogCreate {
	mutation := newElementCatalogMutation(c.config, OpCreate)
	return &ElementCatalogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ElementCatalog entities.
func (c *ElementCatalogClient) CreateBulk(builders ...*ElementCatalogCreate) *ElementCatalogCreateBulk {
	return &ElementCatalogCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ElementCatalogClient) MapCreateBulk(slice any, setFunc func(*ElementCatalogCreate, int)) *ElementCatalogCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ElementCatalogCreateBulk{err: fmt.Errorf("calling to ElementCatalogClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ElementCatalogCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ElementCatalogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ElementCatalog.
func (c *ElementCatalogClient) Update() *ElementCatalogUpdate {
	mutation := newElementCatalogMutation(c.config, OpUpdate)
	return &ElementCatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ElementCatalogClient) UpdateOne(_m *ElementCatalog) *ElementCatalogUpdateOne {
	mutation := newElementCatalogMutation(c.config, OpUpdateOne, withElementCatalog(_m))
	return &ElementCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ElementCatalogClient) UpdateOneID(id int) *ElementCatalogUpdateOne {
	mutation := newElementCatalogMutation(c.config, OpUpdateOne, withElementCatalogID(id))
	return &ElementCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ElementCatalog.
func (c *ElementCatalogClient) Delete() *ElementCatalogDelete {
	mutation := newElementCatalogMutation(c.config, OpDelete)
	return &ElementCatalogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ElementCatalogClient) DeleteOne(_m *ElementCatalog) *ElementCatalogDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ElementCatalogClient) DeleteOneID(id int) *ElementCatalogDeleteOne {
	builder := c.Delete().Where(elementcatalog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ElementCatalogDeleteOne{builder}
}

// Query returns a query builder for ElementCatalog.
func (c *ElementCatalogClient) Query() *ElementCatalogQuery {
	return &ElementCatalogQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeElementCatalog},
		inters: c.Interceptors(),
	}
}

// Get returns a ElementCatalog entity by its id.
func (c *ElementCatalogClient) Get(ctx context.Context, id int) (*ElementCatalog, error) {
	return c.Query().Where(elementcatalog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ElementCatalogClient) GetX(ctx context.Context, id int) *ElementCatalog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChecklistElements queries the checklist_elements edge of a ElementCatalog.
func (c *ElementCatalogClient) QueryChecklistElements(_m *ElementCatalog) *ChecklistElementQuery {
	query := (&ChecklistElementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(elementcatalog.Table, elementcatalog.FieldID, id),
			sqlgraph.To(checklistelement.Table, checklistelement.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, elementcatalog.ChecklistElementsTable, elementcatalog.ChecklistElementsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ElementCatalogClient) Hooks() []Hook {
	return c.hooks.ElementCatalog
}

// Interceptors returns the client interceptors.
func (c *ElementCatalogClient) Interceptors() []Interceptor {
	return c.inters.ElementCatalog
}

func (c *ElementCatalogClient) mutate(ctx context.Context, m *ElementCatalogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ElementCatalogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ElementCatalogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ElementCatalogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ElementCatalogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ElementCatalog mutation op: %q", m.Op())
	}
}

// InspectionActClient is a client for the InspectionAct schema.
type InspectionActClient struct {
	config
}

// NewInspectionActClient returns a client for the InspectionAct from the given config.
func NewInspectionActClient(c config) *InspectionActClient {
	return &InspectionActClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inspectionact.Hooks(f(g(h())))`.
func (c *InspectionActClient) Use(hooks ...Hook) {
	c.hooks.InspectionAct = append(c.hooks.InspectionAct, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inspectionact.Intercept(f(g(h())))`.
func (c *InspectionActClient) Intercept(interceptors ...Interceptor) {
	c.inters.InspectionAct = append(c.inters.InspectionAct, interceptors...)
}

// Create returns a builder for creating a InspectionAct entity.
func (c *InspectionActClient) Create() *InspectionActCreate {
	mutation := newInspectionActMutation(c.config, OpCreate)
	return &InspectionActCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InspectionAct entities.
func (c *InspectionActClient) CreateBulk(builders ...*InspectionActCreate) *InspectionActCreateBulk {
	return &InspectionActCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InspectionActClient) MapCreateBulk(slice any, setFunc func(*InspectionActCreate, int)) *InspectionActCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InspectionActCreateBulk{err: fmt.Errorf("calling to InspectionActClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InspectionActCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InspectionActCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InspectionAct.
func (c *InspectionActClient) Update() *InspectionActUpdate {
	mutation := newInspectionActMutation(c.config, OpUpdate)
	return &InspectionActUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InspectionActClient) UpdateOne(_m *InspectionAct) *InspectionActUpdateOne {
	mutation := newInspectionActMutation(c.config, OpUpdateOne, withInspectionAct(_m))
	return &InspectionActUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InspectionActClient) UpdateOneID(id int) *InspectionActUpdateOne {
	mutation := newInspectionActMutation(c.config, OpUpdateOne, withInspectionActID(id))
	return &InspectionActUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InspectionAct.
func (c *InspectionActClient) Delete() *InspectionActDelete {
	mutation := newInspectionActMutation(c.config, OpDelete)
	return &InspectionActDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InspectionActClient) DeleteOne(_m *InspectionAct) *InspectionActDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InspectionActClient) DeleteOneID(id int) *InspectionActDeleteOne {
	builder := c.Delete().Where(inspectionact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InspectionActDeleteOne{builder}
}

// Query returns a query builder for InspectionAct.
func (c *InspectionActClient) Query() *InspectionActQuery {
	return &InspectionActQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInspectionAct},
		inters: c.Interceptors(),
	}
}

// Get returns a InspectionAct entity by its id.
func (c *InspectionActClient) Get(ctx context.Context, id int) (*InspectionAct, error) {
	return c.Query().Where(inspectionact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InspectionActClient) GetX(ctx context.Context, id int) *InspectionAct {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTask queries the task edge of a InspectionAct.
func (c *InspectionActClient) QueryTask(_m *InspectionAct) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inspectionact.Table, inspectionact.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, inspectionact.TaskTable, inspectionact.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InspectionActClient) Hooks() []Hook {
	return c.hooks.InspectionAct
}

// Interceptors returns the client interceptors.
func (c *InspectionActClient) Interceptors() []Interceptor {
	return c.inters.InspectionAct
}

func (c *InspectionActClient) mutate(ctx context.Context, m *InspectionActMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InspectionActCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InspectionActUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InspectionActUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InspectionActDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InspectionAct mutation op: %q", m.Op())
	}
}

// InspectionResultClient is a client for the InspectionResult schema.
type InspectionResultClient struct {
	config
}

// NewInspectionResultClient returns a client for the InspectionResult from the given config.
func NewInspectionResultClient(c config) *InspectionResultClient {
	return &InspectionResultClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inspectionresult.Hooks(f(g(h())))`.
func (c *InspectionResultClient) Use(hooks ...Hook) {
	c.hooks.InspectionResult = append(c.hooks.InspectionResult, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inspectionresult.Intercept(f(g(h())))`.
func (c *InspectionResultClient) Intercept(interceptors ...Interceptor) {
	c.inters.InspectionResult = append(c.inters.InspectionResult, interceptors...)
}

// Create returns a builder for creating a InspectionResult entity.
func (c *InspectionResultClient) Create() *InspectionResultCreate {
	mutation := newInspectionResultMutation(c.config, OpCreate)
	return &InspectionResultCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InspectionResult entities.
func (c *InspectionResultClient) CreateBulk(builders ...*InspectionResultCreate) *InspectionResultCreateBulk {
	return &InspectionResultCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InspectionResultClient) MapCreateBulk(slice any, setFunc func(*InspectionResultCreate, int)) *InspectionResultCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InspectionResultCreateBulk{err: fmt.Errorf("calling to InspectionResultClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InspectionResultCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InspectionResultCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InspectionResult.
func (c *InspectionResultClient) Update() *InspectionResultUpdate {
	mutation := newInspectionResultMutation(c.config, OpUpdate)
	return &InspectionResultUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InspectionResultClient) UpdateOne(_m *InspectionResult) *InspectionResultUpdateOne {
	mutation := newInspectionResultMutation(c.config, OpUpdateOne, withInspectionResult(_m))
	return &InspectionResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InspectionResultClient) UpdateOneID(id int) *InspectionResultUpdateOne {
	mutation := newInspectionResultMutation(c.config, OpUpdateOne, withInspectionResultID(id))
	return &InspectionResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InspectionResult.
func (c *InspectionResultClient) Delete() *InspectionResultDelete {
	mutation := newInspectionResultMutation(c.config, OpDelete)
	return &InspectionResultDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InspectionResultClient) DeleteOne(_m *InspectionResult) *InspectionResultDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InspectionResultClient) DeleteOneID(id int) *InspectionResultDeleteOne {
	builder := c.Delete().Where(inspectionresult.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InspectionResultDeleteOne{builder}
}

// Query returns a query builder for InspectionResult.
func (c *InspectionResultClient) Query() *InspectionResultQuery {
	return &InspectionResultQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInspectionResult},
		inters: c.Interceptors(),
	}
}

// Get returns a InspectionResult entity by its id.
func (c *InspectionResultClient) Get(ctx context.Context, id int) (*InspectionResult, error) {
	return c.Query().Where(inspectionresult.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InspectionResultClient) GetX(ctx context.Context, id int) *InspectionResult {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTask queries the task edge of a InspectionResult.
func (c *InspectionResultClient) QueryTask(_m *InspectionResult) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inspectionresult.Table, inspectionresult.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inspectionresult.TaskTable, inspectionresult.TaskColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChecklistElement queries the checklist_element edge of a InspectionResult.
func (c *InspectionResultClient) QueryChecklistElement(_m *InspectionResult) *ChecklistElementQuery {
	query := (&ChecklistElementClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inspectionresult.Table, inspectionresult.FieldID, id),
			sqlgraph.To(checklistelement.Table, checklistelement.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inspectionresult.ChecklistElementTable, inspectionresult.ChecklistElementColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InspectionResultClient) Hooks() []Hook {
	return c.hooks.InspectionResult
}

// Interceptors returns the client interceptors.
func (c *InspectionResultClient) Interceptors() []Interceptor {
	return c.inters.InspectionResult
}

func (c *InspectionResultClient) mutate(ctx context.Context, m *InspectionResultMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InspectionResultCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InspectionResultUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InspectionResultUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InspectionResultDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InspectionResult mutation op: %q", m.Op())
	}
}

// InspectorUnitClient is a client for the InspectorUnit schema.
type InspectorUnitClient struct {
	config
}

// NewInspectorUnitClient returns a client for the InspectorUnit from the given config.
func NewInspectorUnitClient(c config) *InspectorUnitClient {
	return &InspectorUnitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inspectorunit.Hooks(f(g(h())))`.
func (c *InspectorUnitClient) Use(hooks ...Hook) {
	c.hooks.InspectorUnit = append(c.hooks.InspectorUnit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `inspectorunit.Intercept(f(g(h())))`.
func (c *InspectorUnitClient) Intercept(interceptors ...Interceptor) {
	c.inters.InspectorUnit = append(c.inters.InspectorUnit, interceptors...)
}

// Create returns a builder for creating a InspectorUnit entity.
func (c *InspectorUnitClient) Create() *InspectorUnitCreate {
	mutation := newInspectorUnitMutation(c.config, OpCreate)
	return &InspectorUnitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InspectorUnit entities.
func (c *InspectorUnitClient) CreateBulk(builders ...*InspectorUnitCreate) *InspectorUnitCreateBulk {
	return &InspectorUnitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InspectorUnitClient) MapCreateBulk(slice any, setFunc func(*InspectorUnitCreate, int)) *InspectorUnitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InspectorUnitCreateBulk{err: fmt.Errorf("calling to InspectorUnitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InspectorUnitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InspectorUnitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InspectorUnit.
func (c *InspectorUnitClient) Update() *InspectorUnitUpdate {
	mutation := newInspectorUnitMutation(c.config, OpUpdate)
	return &InspectorUnitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InspectorUnitClient) UpdateOne(_m *InspectorUnit) *InspectorUnitUpdateOne {
	mutation := newInspectorUnitMutation(c.config, OpUpdateOne, withInspectorUnit(_m))
	return &InspectorUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InspectorUnitClient) UpdateOneID(id int) *InspectorUnitUpdateOne {
	mutation := newInspectorUnitMutation(c.config, OpUpdateOne, withInspectorUnitID(id))
	return &InspectorUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InspectorUnit.
func (c *InspectorUnitClient) Delete() *InspectorUnitDelete {
	mutation := newInspectorUnitMutation(c.config, OpDelete)
	return &InspectorUnitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InspectorUnitClient) DeleteOne(_m *InspectorUnit) *InspectorUnitDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InspectorUnitClient) DeleteOneID(id int) *InspectorUnitDeleteOne {
	builder := c.Delete().Where(inspectorunit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InspectorUnitDeleteOne{builder}
}

// Query returns a query builder for InspectorUnit.
func (c *InspectorUnitClient) Query() *InspectorUnitQuery {
	return &InspectorUnitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInspectorUnit},
		inters: c.Interceptors(),
	}
}

// Get returns a InspectorUnit entity by its id.
func (c *InspectorUnitClient) Get(ctx context.Context, id int) (*InspectorUnit, error) {
	return c.Query().Where(inspectorunit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InspectorUnitClient) GetX(ctx context.Context, id int) *InspectorUnit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInspector queries the inspector edge of a InspectorUnit.
func (c *InspectorUnitClient) QueryInspector(_m *InspectorUnit) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inspectorunit.Table, inspectorunit.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inspectorunit.InspectorTable, inspectorunit.InspectorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJkhUnit queries the jkh_unit edge of a InspectorUnit.
func (c *InspectorUnitClient) QueryJkhUnit(_m *InspectorUnit) *JkhUnitQuery {
	query := (&JkhUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inspectorunit.Table, inspectorunit.FieldID, id),
			sqlgraph.To(jkhunit.Table, jkhunit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inspectorunit.JkhUnitTable, inspectorunit.JkhUnitColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InspectorUnitClient) Hooks() []Hook {
	return c.hooks.InspectorUnit
}

// Interceptors returns the client interceptors.
func (c *InspectorUnitClient) Interceptors() []Interceptor {
	return c.inters.InspectorUnit
}

func (c *InspectorUnitClient) mutate(ctx context.Context, m *InspectorUnitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InspectorUnitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InspectorUnitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InspectorUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InspectorUnitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InspectorUnit mutation op: %q", m.Op())
	}
}

// JkhUnitClient is a client for the JkhUnit schema.
type JkhUnitClient struct {
	config
}

// NewJkhUnitClient returns a client for the JkhUnit from the given config.
func NewJkhUnitClient(c config) *JkhUnitClient {
	return &JkhUnitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `jkhunit.Hooks(f(g(h())))`.
func (c *JkhUnitClient) Use(hooks ...Hook) {
	c.hooks.JkhUnit = append(c.hooks.JkhUnit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `jkhunit.Intercept(f(g(h())))`.
func (c *JkhUnitClient) Intercept(interceptors ...Interceptor) {
	c.inters.JkhUnit = append(c.inters.JkhUnit, interceptors...)
}

// Create returns a builder for creating a JkhUnit entity.
func (c *JkhUnitClient) Create() *JkhUnitCreate {
	mutation := newJkhUnitMutation(c.config, OpCreate)
	return &JkhUnitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of JkhUnit entities.
func (c *JkhUnitClient) CreateBulk(builders ...*JkhUnitCreate) *JkhUnitCreateBulk {
	return &JkhUnitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *JkhUnitClient) MapCreateBulk(slice any, setFunc func(*JkhUnitCreate, int)) *JkhUnitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &JkhUnitCreateBulk{err: fmt.Errorf("calling to JkhUnitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*JkhUnitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &JkhUnitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for JkhUnit.
func (c *JkhUnitClient) Update() *JkhUnitUpdate {
	mutation := newJkhUnitMutation(c.config, OpUpdate)
	return &JkhUnitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JkhUnitClient) UpdateOne(_m *JkhUnit) *JkhUnitUpdateOne {
	mutation := newJkhUnitMutation(c.config, OpUpdateOne, withJkhUnit(_m))
	return &JkhUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JkhUnitClient) UpdateOneID(id int) *JkhUnitUpdateOne {
	mutation := newJkhUnitMutation(c.config, OpUpdateOne, withJkhUnitID(id))
	return &JkhUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for JkhUnit.
func (c *JkhUnitClient) Delete() *JkhUnitDelete {
	mutation := newJkhUnitMutation(c.config, OpDelete)
	return &JkhUnitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JkhUnitClient) DeleteOne(_m *JkhUnit) *JkhUnitDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JkhUnitClient) DeleteOneID(id int) *JkhUnitDeleteOne {
	builder := c.Delete().Where(jkhunit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JkhUnitDeleteOne{builder}
}

// Query returns a query builder for JkhUnit.
func (c *JkhUnitClient) Query() *JkhUnitQuery {
	return &JkhUnitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeJkhUnit},
		inters: c.Interceptors(),
	}
}

// Get returns a JkhUnit entity by its id.
func (c *JkhUnitClient) Get(ctx context.Context, id int) (*JkhUnit, error) {
	return c.Query().Where(jkhunit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JkhUnitClient) GetX(ctx context.Context, id int) *JkhUnit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDistrict queries the district edge of a JkhUnit.
func (c *JkhUnitClient) QueryDistrict(_m *JkhUnit) *DistrictQuery {
	query := (&DistrictClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jkhunit.Table, jkhunit.FieldID, id),
			sqlgraph.To(district.Table, district.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, jkhunit.DistrictTable, jkhunit.DistrictColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuildings queries the buildings edge of a JkhUnit.
func (c *JkhUnitClient) QueryBuildings(_m *JkhUnit) *BuildingQuery {
	query := (&BuildingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jkhunit.Table, jkhunit.FieldID, id),
			sqlgraph.To(building.Table, building.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, jkhunit.BuildingsTable, jkhunit.BuildingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedInspectors queries the assigned_inspectors edge of a JkhUnit.
func (c *JkhUnitClient) QueryAssignedInspectors(_m *JkhUnit) *InspectorUnitQuery {
	query := (&InspectorUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(jkhunit.Table, jkhunit.FieldID, id),
			sqlgraph.To(inspectorunit.Table, inspectorunit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, jkhunit.AssignedInspectorsTable, jkhunit.AssignedInspectorsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JkhUnitClient) Hooks() []Hook {
	return c.hooks.JkhUnit
}

// Interceptors returns the client interceptors.
func (c *JkhUnitClient) Interceptors() []Interceptor {
	return c.inters.JkhUnit
}

func (c *JkhUnitClient) mutate(ctx context.Context, m *JkhUnitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&JkhUnitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&JkhUnitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&JkhUnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&JkhUnitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown JkhUnit mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(_m *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(_m))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id int) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(_m *Role) *RoleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id int) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id int) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id int) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Role.
func (c *RoleClient) QueryUsers(_m *Role) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.UsersTable, role.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	return c.hooks.Role
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// TaskClient is a client for the Task schema.
type TaskClient struct {
	config
}

// NewTaskClient returns a client for the Task from the given config.
func NewTaskClient(c config) *TaskClient {
	return &TaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `task.Hooks(f(g(h())))`.
func (c *TaskClient) Use(hooks ...Hook) {
	c.hooks.Task = append(c.hooks.Task, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `task.Intercept(f(g(h())))`.
func (c *TaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.Task = append(c.inters.Task, interceptors...)
}

// Create returns a builder for creating a Task entity.
func (c *TaskClient) Create() *TaskCreate {
	mutation := newTaskMutation(c.config, OpCreate)
	return &TaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Task entities.
func (c *TaskClient) CreateBulk(builders ...*TaskCreate) *TaskCreateBulk {
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TaskClient) MapCreateBulk(slice any, setFunc func(*TaskCreate, int)) *TaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TaskCreateBulk{err: fmt.Errorf("calling to TaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Task.
func (c *TaskClient) Update() *TaskUpdate {
	mutation := newTaskMutation(c.config, OpUpdate)
	return &TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TaskClient) UpdateOne(_m *Task) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTask(_m))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TaskClient) UpdateOneID(id int) *TaskUpdateOne {
	mutation := newTaskMutation(c.config, OpUpdateOne, withTaskID(id))
	return &TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Task.
func (c *TaskClient) Delete() *TaskDelete {
	mutation := newTaskMutation(c.config, OpDelete)
	return &TaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TaskClient) DeleteOne(_m *Task) *TaskDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TaskClient) DeleteOneID(id int) *TaskDeleteOne {
	builder := c.Delete().Where(task.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TaskDeleteOne{builder}
}

// Query returns a query builder for Task.
func (c *TaskClient) Query() *TaskQuery {
	return &TaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTask},
		inters: c.Interceptors(),
	}
}

// Get returns a Task entity by its id.
func (c *TaskClient) Get(ctx context.Context, id int) (*Task, error) {
	return c.Query().Where(task.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TaskClient) GetX(ctx context.Context, id int) *Task {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInspector queries the inspector edge of a Task.
func (c *TaskClient) QueryInspector(_m *Task) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.InspectorTable, task.InspectorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBuilding queries the building edge of a Task.
func (c *TaskClient) QueryBuilding(_m *Task) *BuildingQuery {
	query := (&BuildingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(building.Table, building.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.BuildingTable, task.BuildingColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChecklist queries the checklist edge of a Task.
func (c *TaskClient) QueryChecklist(_m *Task) *ChecklistQuery {
	query := (&ChecklistClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(checklist.Table, checklist.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, task.ChecklistTable, task.ChecklistColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryResults queries the results edge of a Task.
func (c *TaskClient) QueryResults(_m *Task) *InspectionResultQuery {
	query := (&InspectionResultClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(inspectionresult.Table, inspectionresult.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, task.ResultsTable, task.ResultsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAct queries the act edge of a Task.
func (c *TaskClient) QueryAct(_m *Task) *InspectionActQuery {
	query := (&InspectionActClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(task.Table, task.FieldID, id),
			sqlgraph.To(inspectionact.Table, inspectionact.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, task.ActTable, task.ActColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TaskClient) Hooks() []Hook {
	return c.hooks.Task
}

// Interceptors returns the client interceptors.
func (c *TaskClient) Interceptors() []Interceptor {
	return c.inters.Task
}

func (c *TaskClient) mutate(ctx context.Context, m *TaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Task mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRole queries the role edge of a User.
func (c *UserClient) QueryRole(_m *User) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.RoleTable, user.RoleColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInspections queries the inspections edge of a User.
func (c *UserClient) QueryInspections(_m *User) *TaskQuery {
	query := (&TaskClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(task.Table, task.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.InspectionsTable, user.InspectionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedBuildings queries the assigned_buildings edge of a User.
func (c *UserClient) QueryAssignedBuildings(_m *User) *BuildingQuery {
	query := (&BuildingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(building.Table, building.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignedBuildingsTable, user.AssignedBuildingsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignedUnits queries the assigned_units edge of a User.
func (c *UserClient) QueryAssignedUnits(_m *User) *InspectorUnitQuery {
	query := (&InspectorUnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(inspectorunit.Table, inspectorunit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AssignedUnitsTable, user.AssignedUnitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Building, Checklist, ChecklistElement, District, ElementCatalog, InspectionAct,
		InspectionResult, InspectorUnit, JkhUnit, Role, Task, User []ent.Hook
	}
	inters struct {
		Building, Checklist, ChecklistElement, District, ElementCatalog, InspectionAct,
		InspectionResult, InspectorUnit, JkhUnit, Role, Task, User []ent.Interceptor
	}
)
